<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Model Tensor Debugger</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .drop-zone {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background-color: #fafafa;
        }
        
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #007bff;
            background-color: #f0f8ff;
        }
        
        .drop-zone.file-loaded {
            border-color: #28a745;
            background-color: #f0fff0;
        }
        
        .drop-zone input[type="file"] {
            display: none;
        }
        
        .drop-zone-text {
            font-size: 16px;
            color: #666;
            margin-bottom: 10px;
        }
        
        .file-info {
            font-size: 14px;
            color: #007bff;
            font-weight: bold;
        }
        
        .upload-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            display: block;
            margin: 20px auto;
            transition: background-color 0.3s;
        }
        
        .upload-btn:hover {
            background-color: #0056b3;
        }
        
        .upload-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .progress {
            display: none;
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #007bff;
            width: 0%;
            transition: width 0.3s;
        }
        
        .results {
            margin-top: 30px;
            display: none;
        }
        
        .summary {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .match-item {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .match-item.collapsed {
            padding: 10px 15px;
        }
        
        .match-item.collapsed .match-content {
            display: none;
        }
        
        .match-header {
            font-weight: bold;
            color: #495057;
            margin-bottom: 10px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-radius: 3px;
            transition: background-color 0.2s;
        }
        
        .match-header:hover {
            background-color: #e9ecef;
            padding: 5px 10px;
        }
        
        .collapse-indicator {
            font-size: 14px;
            color: #6c757d;
            transition: transform 0.2s;
        }
        
        .match-item.collapsed .collapse-indicator {
            transform: rotate(-90deg);
        }
        
        .match-summary {
            font-size: 12px;
            color: #6c757d;
            font-weight: normal;
            margin-left: 10px;
        }
        
        .tensor-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .tensor-details {
            background-color: white;
            padding: 10px;
            border-radius: 3px;
            border-left: 4px solid #007bff;
        }
        
        .diff-stats {
            background-color: #fff3cd;
            padding: 10px;
            border-radius: 3px;
            border-left: 4px solid #ffc107;
            margin-bottom: 15px;
        }
        
        .error {
            color: #dc3545;
            background-color: #f8d7da;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
        }
        
        .plot-container {
            margin-top: 15px;
            min-height: 400px;
        }
        
        .shape-mismatch {
            background-color: #f8d7da;
            border-left-color: #dc3545;
        }
        
        .layer-group {
            margin-bottom: 30px;
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 20px;
            background-color: #f8f9fa;
        }
        
        .layer-group h3 {
            color: #007bff;
            margin-top: 0;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        
        .inspect-btn {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 10px 0;
        }
        
        .inspect-btn:hover {
            background-color: #218838;
        }
        
        .values-container {
            background-color: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
        }
        
        .slice-controls {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        
        .slider-group {
            margin-bottom: 15px;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #495057;
        }
        
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            margin: 5px 0;
        }
        
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .slider-group input[type="range"]::-webkit-slider-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #ddd;
            border-radius: 3px;
        }
        
        .slider-group input[type="range"]::-moz-range-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #ddd;
            border-radius: 3px;
            border: none;
        }
        
        .manual-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #dee2e6;
        }
        
        .manual-controls input[type="number"] {
            width: 80px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .manual-controls button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .manual-controls button:hover {
            background-color: #0056b3;
        }
        
        .slider-group span {
            color: #007bff;
            font-weight: bold;
            font-family: monospace;
        }
        
        .tensor-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .tensor-column h4 {
            background-color: #007bff;
            color: white;
            padding: 8px 12px;
            margin: 0 0 10px 0;
            border-radius: 3px;
        }
        
        .values-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 2px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            padding: 5px;
            background-color: #fafafa;
        }
        
        .value-cell {
            background-color: white;
            padding: 6px 8px;
            border: 1px solid #eee;
            border-radius: 2px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            text-align: right;
            cursor: help;
        }
        
        .value-cell:hover {
            background-color: #e3f2fd;
        }
        
        .tensor-info-display {
            background-color: #f1f3f4;
            padding: 10px;
            margin-top: 15px;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }
        
        .summary-stats {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .summary-stats h5 {
            margin: 0 0 10px 0;
            color: #495057;
            font-weight: bold;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #e9ecef;
        }
        
        .stat-item.highlight {
            background-color: #fff3cd;
            border-color: #ffeaa7;
            font-weight: bold;
        }
        
        .stat-label {
            color: #495057;
            font-size: 14px;
        }
        
        .stat-value {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #2c3e50;
            font-weight: bold;
        }
        
        .summary-stats.error {
            background-color: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }
        
        .summary-stats.single-model {
            background-color: #fff3cd;
            border-color: #ffc107;
        }
        
        .single-model-note {
            text-align: center;
            font-style: italic;
            color: #856404;
            margin-top: 10px;
            padding: 5px;
            background-color: #ffeaa7;
            border-radius: 3px;
        }
        
        .tensor-details.missing {
            background-color: #f8f9fa;
            color: #6c757d;
            font-style: italic;
        }
        
        .tensor-details.single-tensor {
            background-color: #d4edda;
            border-left-color: #28a745;
        }
        
        .missing-column {
            background-color: #f8f9fa;
            opacity: 0.6;
        }
        
        .missing-notice {
            padding: 20px;
            text-align: center;
            color: #6c757d;
            font-style: italic;
            background-color: #e9ecef;
            border-radius: 3px;
            margin: 10px;
        }
        
        .floating-header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: linear-gradient(135deg, #007bff, #28a745);
            color: white;
            padding: 10px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: none;
            border-radius: 0 0 8px 8px;
            margin-bottom: 20px;
        }
        
        .floating-header.visible {
            display: block;
        }
        
        .header-content {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            gap: 20px;
        }
        
        .model-info {
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            background: rgba(255,255,255,0.1);
            padding: 5px 10px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .model-info.model1 {
            text-align: left;
        }
        
        .model-info.model2 {
            text-align: right;
        }
        
        .vs-divider {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            color: #ffd700;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ML Model Tensor Debugger</h1>
        
        <div class="upload-section">
            <div class="drop-zone" id="model1-drop">
                <input type="file" id="model1-file" accept=".zip,.tar.gz,.tgz">
                <div class="drop-zone-text">Drop Model 1 archive here</div>
                <div class="file-info" id="model1-info"></div>
            </div>
            
            <div class="drop-zone" id="model2-drop">
                <input type="file" id="model2-file" accept=".zip,.tar.gz,.tgz">
                <div class="drop-zone-text">Drop Model 2 archive here</div>
                <div class="file-info" id="model2-info"></div>
            </div>
        </div>
        
        <button class="upload-btn" id="upload-btn" disabled>Compare Models</button>
        
        <div class="progress" id="progress">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        
        <div class="results" id="results">
            <div class="floating-header" id="floating-header">
                <div class="header-content">
                    <div class="model-info model1" id="floating-model1">Model 1</div>
                    <div class="vs-divider">VS</div>
                    <div class="model-info model2" id="floating-model2">Model 2</div>
                </div>
            </div>
            <div class="summary" id="summary"></div>
            <div style="text-align: center; margin: 20px 0; display: none;" id="control-buttons">
                <button class="upload-btn" onclick="collapseAll()" style="background-color: #6c757d;">
                    📉 Collapse All
                </button>
                <button class="upload-btn" onclick="expandAll()" style="background-color: #28a745; margin-left: 10px;">
                    📈 Expand All
                </button>
            </div>
            <div id="matches-container"></div>
        </div>
    </div>

    <script>
        let model1File = null;
        let model2File = null;
        
        // Setup drag and drop
        function setupDropZone(dropZoneId, fileInputId, infoId) {
            const dropZone = document.getElementById(dropZoneId);
            const fileInput = document.getElementById(fileInputId);
            const fileInfo = document.getElementById(infoId);
            
            dropZone.addEventListener('click', () => fileInput.click());
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    fileInput.files = files;
                    handleFileSelect(fileInput, dropZone, fileInfo);
                }
            });
            
            fileInput.addEventListener('change', () => {
                handleFileSelect(fileInput, dropZone, fileInfo);
            });
        }
        
        function handleFileSelect(fileInput, dropZone, fileInfo) {
            const file = fileInput.files[0];
            if (file) {
                dropZone.classList.add('file-loaded');
                fileInfo.textContent = `${file.name} (${formatFileSize(file.size)})`;
                
                if (fileInput.id === 'model1-file') {
                    model1File = file;
                } else {
                    model2File = file;
                }
                
                updateUploadButton();
            }
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function updateUploadButton() {
            const uploadBtn = document.getElementById('upload-btn');
            uploadBtn.disabled = !(model1File && model2File);
        }
        
        function showProgress() {
            document.getElementById('progress').style.display = 'block';
            document.getElementById('progress-bar').style.width = '0%';
        }
        
        function hideProgress() {
            document.getElementById('progress').style.display = 'none';
        }
        
        function updateProgress(percent) {
            document.getElementById('progress-bar').style.width = percent + '%';
        }
        
        async function uploadAndCompare() {
            showProgress();
            updateProgress(10);
            
            const formData = new FormData();
            formData.append('model1', model1File);
            formData.append('model2', model2File);
            
            try {
                updateProgress(50);
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                
                updateProgress(80);
                const result = await response.json();
                
                if (result.error) {
                    throw new Error(result.error);
                }
                
                updateProgress(90);
                await displayResults(result);
                updateProgress(100);
                
                setTimeout(hideProgress, 500);
                
            } catch (error) {
                hideProgress();
                document.getElementById('results').innerHTML = 
                    `<div class="error">Error: ${error.message}</div>`;
                document.getElementById('results').style.display = 'block';
            }
        }
        
        let globalMatches = []; // Store matches globally for tensor inspection

        async function displayResults(data) {
            const resultsDiv = document.getElementById('results');
            const summaryDiv = document.getElementById('summary');
            const matchesContainer = document.getElementById('matches-container');
            const floatingHeader = document.getElementById('floating-header');
            const floatingModel1 = document.getElementById('floating-model1');
            const floatingModel2 = document.getElementById('floating-model2');
            
            globalMatches = data.matches;
            
            // Update floating header with model names
            const model1Name = model1File ? model1File.name : 'Model 1';
            const model2Name = model2File ? model2File.name : 'Model 2';
            floatingModel1.textContent = model1Name;
            floatingModel2.textContent = model2Name;
            floatingHeader.classList.add('visible');
            
            summaryDiv.innerHTML = `
                <h3>Tensor Comparison Results</h3>
                <p>Model 1: ${data.model1_files} tensor files (${model1Name})</p>
                <p>Model 2: ${data.model2_files} tensor files (${model2Name})</p>
                <p>Matched pairs: ${data.matches.length}</p>
            `;
            
            matchesContainer.innerHTML = '';
            
            // Group matches by layer
            const layerGroups = {};
            data.matches.forEach((match, index) => {
                if (!layerGroups[match.layer_num]) {
                    layerGroups[match.layer_num] = [];
                }
                layerGroups[match.layer_num].push({...match, match_index: index});
            });
            
            // Display each layer group
            Object.keys(layerGroups).sort((a, b) => parseInt(a) - parseInt(b)).forEach(layerNum => {
                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer-group';
                layerDiv.innerHTML = `<h3>Layer ${layerNum}</h3>`;
                
                layerGroups[layerNum].forEach(match => {
                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'match-item collapsed'; // Start collapsed by default
                    matchDiv.setAttribute('data-match-index', match.match_index);
                    
                    // Generate summary statistics display
                    let summaryContent = '';
                    
                    if (match.match_type === 'both' && match.diff_stats && !match.diff_stats.error) {
                        if (match.diff_stats.shape_match) {
                            summaryContent = `
                                <div class="summary-stats">
                                    <h5>Summary Statistics</h5>
                                    <div class="stats-grid">
                                        <div class="stat-item">
                                            <span class="stat-label">Model 1 Mean:</span>
                                            <span class="stat-value">${match.model1_data.mean.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Model 2 Mean:</span>
                                            <span class="stat-value">${match.model2_data.mean.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Model 1 Std:</span>
                                            <span class="stat-value">${match.model1_data.std.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Model 2 Std:</span>
                                            <span class="stat-value">${match.model2_data.std.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item highlight">
                                            <span class="stat-label">Max Difference:</span>
                                            <span class="stat-value">${match.diff_stats.abs_diff_max.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item highlight">
                                            <span class="stat-label">Cosine Similarity:</span>
                                            <span class="stat-value">${match.diff_stats.cosine_sim.toFixed(6)}</span>
                                        </div>
                                    </div>
                                </div>
                            `;
                        } else {
                            summaryContent = `
                                <div class="summary-stats error">
                                    <strong>Shape Mismatch:</strong><br>
                                    Model 1: [${match.diff_stats.shape1.join(', ')}]<br>
                                    Model 2: [${match.diff_stats.shape2.join(', ')}]<br>
                                    <em>${match.diff_stats.error || 'Cannot reshape for tensor parallel compatibility'}</em>
                                </div>
                            `;
                        }
                    } else if (match.match_type === 'model1_only') {
                        summaryContent = `
                            <div class="summary-stats single-model">
                                <h5>Single Model Statistics</h5>
                                <div class="stats-grid">
                                    <div class="stat-item">
                                        <span class="stat-label">Model 1 Mean:</span>
                                        <span class="stat-value">${match.model1_data.mean.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 1 Std:</span>
                                        <span class="stat-value">${match.model1_data.std.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 1 Min:</span>
                                        <span class="stat-value">${match.model1_data.min.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 1 Max:</span>
                                        <span class="stat-value">${match.model1_data.max.toFixed(6)}</span>
                                    </div>
                                </div>
                                <div class="single-model-note">⚠️ Only available in Model 1</div>
                            </div>
                        `;
                    } else if (match.match_type === 'model2_only') {
                        summaryContent = `
                            <div class="summary-stats single-model">
                                <h5>Single Model Statistics</h5>
                                <div class="stats-grid">
                                    <div class="stat-item">
                                        <span class="stat-label">Model 2 Mean:</span>
                                        <span class="stat-value">${match.model2_data.mean.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 2 Std:</span>
                                        <span class="stat-value">${match.model2_data.std.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 2 Min:</span>
                                        <span class="stat-value">${match.model2_data.min.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 2 Max:</span>
                                        <span class="stat-value">${match.model2_data.max.toFixed(6)}</span>
                                    </div>
                                </div>
                                <div class="single-model-note">⚠️ Only available in Model 2</div>
                            </div>
                        `;
                    } else if (match.diff_stats && match.diff_stats.error) {
                        summaryContent = `
                            <div class="summary-stats error">
                                <strong>Error:</strong> ${match.diff_stats.error}
                            </div>
                        `;
                    }

                    // Generate tensor info display based on match type
                    let tensorInfoContent = '';
                    if (match.match_type === 'both') {
                        tensorInfoContent = `
                            <div class="tensor-details">
                                <strong>Model 1:</strong> ${match.model1_file}<br>
                                Shape: [${match.model1_data.shape.join(', ')}]
                            </div>
                            <div class="tensor-details">
                                <strong>Model 2:</strong> ${match.model2_file}<br>
                                Shape: [${match.model2_data.shape.join(', ')}]
                            </div>
                        `;
                    } else if (match.match_type === 'model1_only') {
                        tensorInfoContent = `
                            <div class="tensor-details single-tensor">
                                <strong>Model 1:</strong> ${match.model1_file}<br>
                                Shape: [${match.model1_data.shape.join(', ')}]
                            </div>
                            <div class="tensor-details missing">
                                <strong>Model 2:</strong> <em>Not available</em>
                            </div>
                        `;
                    } else if (match.match_type === 'model2_only') {
                        tensorInfoContent = `
                            <div class="tensor-details missing">
                                <strong>Model 1:</strong> <em>Not available</em>
                            </div>
                            <div class="tensor-details single-tensor">
                                <strong>Model 2:</strong> ${match.model2_file}<br>
                                Shape: [${match.model2_data.shape.join(', ')}]
                            </div>
                        `;
                    }

                    // Create a summary for the collapsed view
                    let quickSummary = '';
                    if (match.match_type === 'both' && match.diff_stats && !match.diff_stats.error && match.diff_stats.shape_match) {
                        quickSummary = `<span class="match-summary">Max Diff: ${match.diff_stats.abs_diff_max.toFixed(6)}, Cosine Sim: ${match.diff_stats.cosine_sim.toFixed(4)}</span>`;
                    } else if (match.match_type !== 'both') {
                        quickSummary = `<span class="match-summary">Single model only</span>`;
                    } else if (match.diff_stats && match.diff_stats.error) {
                        quickSummary = `<span class="match-summary">Error: ${match.diff_stats.error}</span>`;
                    }

                    matchDiv.innerHTML = `
                        <div class="match-header" onclick="toggleMatch(${match.match_index})">
                            <div>
                                <span>${match.stage_display}</span>
                                ${quickSummary}
                            </div>
                            <span class="collapse-indicator">▼</span>
                        </div>
                        <div class="match-content">
                            <div class="tensor-info">
                                ${tensorInfoContent}
                            </div>
                            ${summaryContent}
                            <div class="tensor-values">
                                <button class="inspect-btn" onclick="showTensorValues(${match.match_index})">
                                    Inspect Raw Tensor Values
                                </button>
                                ${match.match_type === 'both' ? `<button class="inspect-btn" onclick="jumpToMaxDiffInTensor(${match.match_index})" style="background-color: #dc3545; margin-left: 10px;">🎯 Jump to Max Diff</button>` : ''}
                                <div class="values-container" id="values-${match.match_index}" style="display: none;">
                                    <div class="slice-controls">
                                        <div id="dimension-controls-${match.match_index}"></div>
                                        <div class="slider-group">
                                            <label for="count-slider-${match.match_index}">Values to Show: <span id="count-value-${match.match_index}">10</span></label>
                                            <input type="range" id="count-slider-${match.match_index}" min="1" max="100" value="10" 
                                                   oninput="updateSliderValue(${match.match_index}, 'count')" 
                                                   onchange="updateTensorValues(${match.match_index})">
                                        </div>
                                        <div class="manual-controls">
                                            <input type="number" id="count-input-${match.match_index}" value="10" min="1" max="100" 
                                                   onchange="syncSliderFromInput(${match.match_index}, 'count')" placeholder="Count">
                                            <button onclick="updateTensorValues(${match.match_index})">Update</button>
                                            <button onclick="resetDimensionSliders(${match.match_index})" style="background-color: #6c757d; margin-left: 10px;">Reset</button>
                                        </div>
                                    </div>
                                    <div id="tensor-display-${match.match_index}"></div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    layerDiv.appendChild(matchDiv);
                });
                
                matchesContainer.appendChild(layerDiv);
            });
            
            resultsDiv.style.display = 'block';
            
            // Show the control buttons
            document.getElementById('control-buttons').style.display = 'block';
        }
        
        async function showTensorValues(matchIndex) {
            const valuesContainer = document.getElementById(`values-${matchIndex}`);
            if (valuesContainer.style.display === 'none') {
                valuesContainer.style.display = 'block';
                // Initialize slider ranges based on tensor size when first shown
                await initializeSliderRanges(matchIndex);
                await updateTensorValues(matchIndex);
            } else {
                valuesContainer.style.display = 'none';
            }
        }
        
        async function initializeSliderRanges(matchIndex) {
            // Get the ACTUAL tensor shape after TP-aware reshaping from the backend
            if (globalMatches[matchIndex]) {
                const match = globalMatches[matchIndex];
                // Make a quick request to get the final tensor info after any reshaping
                try {
                    const response = await fetch('/get_tensor_values', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            match_index: matchIndex,
                            dimension_indices: [],
                            count: 1,
                            get_final_shape: true  // Request final shape after reshaping
                        }),
                    });
                    const result = await response.json();
                    
                    if (!result.error && result.tensor_shape) {
                        // Use the final tensor shape from backend (after TP-aware reshaping)
                        console.log(`Creating sliders for final shape: [${result.tensor_shape.join(', ')}]`);
                        createDimensionSliders(matchIndex, result.tensor_shape, result.original_shapes);
                    } else {
                        // Fallback for scalar or error cases
                        createDimensionSliders(matchIndex, result.tensor_shape || [], null);
                    }
                } catch (error) {
                    console.log('Could not initialize slider range:', error);
                    createDimensionSliders(matchIndex, [], null);
                }
            }
        }
        
        function createDimensionSliders(matchIndex, tensorShape, originalShapes) {
            const dimensionContainer = document.getElementById(`dimension-controls-${matchIndex}`);
            
            if (tensorShape.length === 0) {
                // Scalar tensor - no dimension sliders needed
                dimensionContainer.innerHTML = '<p><em>Scalar value - no dimensions to slice</em></p>';
                return;
            }
            
            if (tensorShape.length === 1) {
                // 1D tensor - single dimension slider
                dimensionContainer.innerHTML = `
                    <div class="slider-group">
                        <label for="dim0-slider-${matchIndex}">Index (Dimension 0): <span id="dim0-value-${matchIndex}">0</span></label>
                        <input type="range" id="dim0-slider-${matchIndex}" min="0" max="${tensorShape[0] - 1}" value="0" 
                               oninput="updateDimensionSlider(${matchIndex}, 0)" 
                               onchange="updateTensorValues(${matchIndex})">
                    </div>
                `;
                return;
            }
            
            // Multi-dimensional tensor - create sliders for the FINAL tensor shape
            let slidersHTML = '<p><strong>Dimension Sliders (Final Shape):</strong></p>';
            
            // Show original shapes if available
            if (originalShapes) {
                slidersHTML += `<p><em>Original shapes: [${originalShapes.shape1.join(', ')}] vs [${originalShapes.shape2.join(', ')}] → Final: [${tensorShape.join(', ')}]</em></p>`;
            }
            
            // Create sliders for each dimension of the final tensor shape
            for (let i = 0; i < tensorShape.length; i++) {
                const dimSize = tensorShape[i];
                slidersHTML += `
                    <div class="slider-group">
                        <label for="dim${i}-slider-${matchIndex}">Dim ${i} (size ${dimSize}): <span id="dim${i}-value-${matchIndex}">0</span></label>
                        <input type="range" id="dim${i}-slider-${matchIndex}" min="0" max="${dimSize - 1}" value="0" 
                               oninput="updateDimensionSlider(${matchIndex}, ${i})" 
                               onchange="updateTensorValues(${matchIndex})">
                    </div>
                `;
            }
            
            dimensionContainer.innerHTML = slidersHTML;
        }
        
        function updateDimensionSlider(matchIndex, dimensionIndex) {
            const slider = document.getElementById(`dim${dimensionIndex}-slider-${matchIndex}`);
            const valueSpan = document.getElementById(`dim${dimensionIndex}-value-${matchIndex}`);
            
            if (slider && valueSpan) {
                valueSpan.textContent = slider.value;
            }
        }
        
        function getDimensionIndices(matchIndex) {
            const indices = [];
            const dimensionContainer = document.getElementById(`dimension-controls-${matchIndex}`);
            const sliders = dimensionContainer.querySelectorAll('input[type="range"]');
            
            // Simply get the slider values in order - they now correspond directly to final tensor dimensions
            sliders.forEach((slider, index) => {
                const value = parseInt(slider.value) || 0;
                indices.push(value);
            });
            
            return indices;
        }
        
        function resetDimensionSliders(matchIndex) {
            const dimensionContainer = document.getElementById(`dimension-controls-${matchIndex}`);
            const sliders = dimensionContainer.querySelectorAll('input[type="range"]');
            
            sliders.forEach((slider, index) => {
                slider.value = 0;
                updateDimensionSlider(matchIndex, index);
            });
            
            updateTensorValues(matchIndex);
        }
        
        function updateSliderValue(matchIndex, type) {
            if (type === 'count') {
                const slider = document.getElementById(`count-slider-${matchIndex}`);
                const valueSpan = document.getElementById(`count-value-${matchIndex}`);
                const input = document.getElementById(`count-input-${matchIndex}`);
                valueSpan.textContent = slider.value;
                input.value = slider.value;
            }
        }
        
        function syncSliderFromInput(matchIndex, type) {
            if (type === 'count') {
                const input = document.getElementById(`count-input-${matchIndex}`);
                const slider = document.getElementById(`count-slider-${matchIndex}`);
                const valueSpan = document.getElementById(`count-value-${matchIndex}`);
                const value = Math.max(1, Math.min(100, parseInt(input.value) || 10));
                slider.value = value;
                valueSpan.textContent = value;
                input.value = value;
                updateTensorValues(matchIndex);
            }
        }
        
        async function updateTensorValues(matchIndex) {
            const countSlider = document.getElementById(`count-slider-${matchIndex}`);
            const displayDiv = document.getElementById(`tensor-display-${matchIndex}`);
            
            const dimensionIndices = getDimensionIndices(matchIndex);
            const count = parseInt(countSlider.value) || 10;
            
            displayDiv.innerHTML = '<div class="loading">Loading tensor values...</div>';
            
            try {
                const response = await fetch('/get_tensor_values', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        match_index: matchIndex,
                        dimension_indices: dimensionIndices,
                        count: count
                    }),
                });
                
                const result = await response.json();
                
                if (result.error) {
                    displayDiv.innerHTML = `<div class="error">Error: ${result.error}</div>`;
                    return;
                }
                
                // Initialize variables needed for display
                const indexOffset = 0; // For tooltip indexing
                
                // Define color functions for all cases
                const getBackgroundColor = (value, allValues = null) => {
                    const absValue = Math.abs(value);
                    
                    // Calculate intensity based on magnitude if we have all values for context
                    let intensity = 0.5; // Default medium intensity
                    if (allValues && allValues.length > 0) {
                        const maxAbs = Math.max(...allValues.map(v => Math.abs(v)));
                        const minAbs = Math.min(...allValues.map(v => Math.abs(v)));
                        if (maxAbs > minAbs) {
                            intensity = (absValue - minAbs) / (maxAbs - minAbs);
                        }
                    }
                    
                    if (value < 0) {
                        // Blue gradient: light blue to medium blue based on magnitude
                        const red = Math.floor(173 - (173 - 100) * intensity);   // 173 (light blue) to 100 (medium blue)
                        const green = Math.floor(216 - (216 - 149) * intensity); // 216 (light blue) to 149 (medium blue)  
                        const blue = Math.floor(230 - (230 - 237) * intensity);  // 230 (light blue) to 237 (medium blue)
                        return `rgb(${red}, ${green}, ${blue})`;
                    } else {
                        // Orange gradient: light orange to dark orange based on magnitude
                        const red = Math.floor(255 - (255 - 255) * intensity);   // 255 (light orange) to 255 (dark orange)
                        const green = Math.floor(228 - (228 - 140) * intensity); // 228 (light orange) to 140 (dark orange)
                        const blue = Math.floor(181 - (181 - 0) * intensity);    // 181 (light orange) to 0 (dark orange)
                        return `rgb(${red}, ${green}, ${blue})`;
                    }
                };
                
                const getBorderColor = (diff, maxDiffValue) => {
                    if (!maxDiffValue || maxDiffValue === 0) return '#90EE90'; // Light green if no difference
                    const normalizationFactor = 0.5; // 0.5 difference = dark color
                    const intensity = Math.min(diff / normalizationFactor, 1.0); // Cap at 1.0
                    
                    // Green to orange gradient for borders
                    const red = Math.floor(144 + (255 - 144) * intensity);   // 144 (light green) to 255 (orange)
                    const green = Math.floor(238 - (84 * intensity));        // 238 (light green) to 154 (orange)
                    const blue = Math.floor(144 - (144 * intensity));        // 144 (light green) to 0 (orange)
                    
                    return `rgb(${red}, ${green}, ${blue})`;
                };
                
                // Handle single model displays
                let tensorComparisonContent = '';
                
                if (result.tensor1_values && result.tensor2_values) {
                    // Both models have data - calculate differences and color code
                    const differences = result.tensor1_values.map((val1, idx) => 
                        Math.abs(val1 - result.tensor2_values[idx])
                    );
                    const maxDiff = Math.max(...differences);
                    const normalizationFactor = 0.5; // 0.5 difference = dark color
                    
                    // Store max difference for this tensor globally
                    if (!window.globalMaxDifferences) {
                        window.globalMaxDifferences = [];
                    }
                    window.globalMaxDifferences[matchIndex] = {
                        maxDiff: maxDiff,
                        layer: globalMatches[matchIndex]?.layer_num,
                        stage: globalMatches[matchIndex]?.stage_display,
                        matchIndex: matchIndex
                    };
                    
                    tensorComparisonContent = `
                        <div class="tensor-comparison">
                            <div class="tensor-column">
                                <h4>Model 1 Values</h4>
                                <div class="values-grid">
                                    ${result.tensor1_values.map((val, idx) => {
                                        const diff = differences[idx];
                                        const bgColor = getBackgroundColor(val, result.tensor1_values);
                                        const borderColor = getBorderColor(diff, maxDiff);
                                        return `<div class="value-cell" 
                                                style="background-color: ${bgColor}; border: 2px solid ${borderColor};" 
                                                title="Index: ${indexOffset + idx}, Value: ${val.toFixed(6)}, Diff: ${diff.toFixed(6)}">${val.toFixed(6)}</div>`;
                                    }).join('')}
                                </div>
                            </div>
                            <div class="tensor-column">
                                <h4>Model 2 Values</h4>
                                <div class="values-grid">
                                    ${result.tensor2_values.map((val, idx) => {
                                        const diff = differences[idx];
                                        const bgColor = getBackgroundColor(val, result.tensor2_values);
                                        const borderColor = getBorderColor(diff, maxDiff);
                                        return `<div class="value-cell" 
                                                style="background-color: ${bgColor}; border: 2px solid ${borderColor};" 
                                                title="Index: ${indexOffset + idx}, Value: ${val.toFixed(6)}, Diff: ${diff.toFixed(6)}">${val.toFixed(6)}</div>`;
                                    }).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                } else if (result.tensor1_values) {
                    // Only Model 1 has data
                    tensorComparisonContent = `
                        <div class="tensor-comparison single-model">
                            <div class="tensor-column">
                                <h4>Model 1 Values</h4>
                                <div class="values-grid">
                                    ${result.tensor1_values.map((val, idx) => {
                                        const bgColor = getBackgroundColor(val, result.tensor1_values);
                                        return `<div class="value-cell" 
                                                style="background-color: ${bgColor}; border: 2px solid #90EE90;" 
                                                title="Index: ${indexOffset + idx}, Value: ${val.toFixed(6)}">${val.toFixed(6)}</div>`;
                                    }).join('')}
                                </div>
                            </div>
                            <div class="tensor-column missing-column">
                                <h4>Model 2 Values</h4>
                                <div class="missing-notice">Not available in Model 2</div>
                            </div>
                        </div>
                    `;
                } else if (result.tensor2_values) {
                    // Only Model 2 has data
                    tensorComparisonContent = `
                        <div class="tensor-comparison single-model">
                            <div class="tensor-column missing-column">
                                <h4>Model 1 Values</h4>
                                <div class="missing-notice">Not available in Model 1</div>
                            </div>
                            <div class="tensor-column">
                                <h4>Model 2 Values</h4>
                                <div class="values-grid">
                                    ${result.tensor2_values.map((val, idx) => {
                                        const bgColor = getBackgroundColor(val, result.tensor2_values);
                                        return `<div class="value-cell" 
                                                style="background-color: ${bgColor}; border: 2px solid #90EE90;" 
                                                title="Index: ${indexOffset + idx}, Value: ${val.toFixed(6)}">${val.toFixed(6)}</div>`;
                                    }).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                const valueCount = result.tensor1_values ? result.tensor1_values.length : result.tensor2_values.length;
                const dimensionInfo = dimensionIndices.length > 0 ? `at indices [${dimensionIndices.join(', ')}]` : 'flattened view';
                
                displayDiv.innerHTML = `
                    ${tensorComparisonContent}
                    <div class="tensor-info-display">
                        <p><strong>Shape:</strong> [${result.tensor_shape.join(', ')}]</p>
                        <p><strong>Display Type:</strong> ${result.display_type}</p>
                        <p><strong>Viewing:</strong> ${valueCount} values ${dimensionInfo}</p>
                        ${result.slice_info ? `<p><strong>Slice Details:</strong> ${result.slice_info}</p>` : ''}
                    </div>
                `;
                
            } catch (error) {
                displayDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
            }
        }
        
        async function jumpToMaxDiffInTensor(matchIndex) {
            // First, expand the tensor values container if it's not already visible
            const valuesContainer = document.getElementById(`values-${matchIndex}`);
            if (valuesContainer && valuesContainer.style.display === 'none') {
                await showTensorValues(matchIndex);
            }
            
            // Make a request to get the argmax coordinates
            try {
                const response = await fetch('/get_tensor_values', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        match_index: matchIndex,
                        dimension_indices: [],
                        count: 1,
                        get_argmax: true  // Request argmax coordinates
                    }),
                });
                
                const result = await response.json();
                
                if (result.error) {
                    alert(`Error: ${result.error}`);
                    return;
                }
                
                if (!result.argmax_coordinates || result.argmax_coordinates.length === 0) {
                    // No argmax available for this tensor (might be single-model or scalar)
                    alert('No maximum difference location available for this tensor.');
                    return;
                }
                
                const argmaxCoords = result.argmax_coordinates;
                
                // Update dimension sliders to show the argmax position
                const dimensionContainer = document.getElementById(`dimension-controls-${matchIndex}`);
                const sliders = dimensionContainer.querySelectorAll('input[type="range"]');
                
                // Set each dimension slider to the argmax coordinate
                sliders.forEach((slider, dimIndex) => {
                    if (dimIndex < argmaxCoords.length) {
                        slider.value = argmaxCoords[dimIndex];
                        updateDimensionSlider(matchIndex, dimIndex);
                    }
                });
                
                // Update tensor values with the new position
                await updateTensorValues(matchIndex);
                
                // Scroll to the display and highlight it
                const displayDiv = document.getElementById(`tensor-display-${matchIndex}`);
                if (displayDiv) {
                    displayDiv.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'start' 
                    });
                    
                    // Highlight the tensor display
                    displayDiv.style.border = '3px solid #ff4444';
                    setTimeout(() => {
                        displayDiv.style.border = '';
                    }, 3000);
                    
                    // Show success message
                    const coords = argmaxCoords.join(', ');
                    const tempMessage = document.createElement('div');
                    tempMessage.innerHTML = `<div style="background: #28a745; color: white; padding: 10px; border-radius: 5px; margin: 10px 0; text-align: center;">🎯 Jumped to max difference at coordinates [${coords}]</div>`;
                    displayDiv.insertBefore(tempMessage, displayDiv.firstChild);
                    
                    setTimeout(() => {
                        tempMessage.remove();
                    }, 3000);
                }
                
            } catch (error) {
                alert(`Error finding max difference: ${error.message}`);
            }
        }
        
        function collapseAll() {
            const matchItems = document.querySelectorAll('.match-item');
            matchItems.forEach(item => {
                item.classList.add('collapsed');
            });
        }
        
        function expandAll() {
            const matchItems = document.querySelectorAll('.match-item');
            matchItems.forEach(item => {
                item.classList.remove('collapsed');
            });
        }
        
        function toggleMatch(matchIndex) {
            const matchItem = document.querySelector(`[data-match-index="${matchIndex}"]`);
            if (matchItem) {
                matchItem.classList.toggle('collapsed');
            }
        }
        
        // Initialize
        setupDropZone('model1-drop', 'model1-file', 'model1-info');
        setupDropZone('model2-drop', 'model2-file', 'model2-info');
        
        document.getElementById('upload-btn').addEventListener('click', uploadAndCompare);
    </script>
</body>
</html>