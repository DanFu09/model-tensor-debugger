<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Model Tensor Debugger</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .upload-section.single-file {
            grid-template-columns: 1fr;
            justify-items: center;
        }
        
        .drop-zone {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background-color: #fafafa;
        }
        
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #007bff;
            background-color: #f0f8ff;
        }
        
        .drop-zone.file-loaded {
            border-color: #28a745;
            background-color: #f0fff0;
        }
        
        .drop-zone input[type="file"] {
            display: none;
        }
        
        .drop-zone-text {
            font-size: 16px;
            color: #666;
            margin-bottom: 10px;
        }
        
        .file-info {
            font-size: 14px;
            color: #007bff;
            font-weight: bold;
        }
        
        .upload-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            display: block;
            margin: 20px auto;
            transition: background-color 0.3s;
        }
        
        .upload-btn:hover {
            background-color: #0056b3;
        }
        
        .upload-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .progress {
            display: none;
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #007bff;
            width: 0%;
            transition: width 0.5s ease-out;
            position: relative;
            border-radius: 10px;
        }
        
        .progress-bar::after {
            content: attr(data-percentage);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .progress-text {
            text-align: center;
            margin-top: 10px;
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }
        
        .size-warning {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            display: none;
        }
        
        .size-warning-title {
            font-weight: bold;
            color: #856404;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        
        .size-warning-title::before {
            content: "⚠️";
            margin-right: 8px;
        }
        
        .size-warning-text {
            color: #856404;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .size-warning-suggestions {
            margin-top: 10px;
            padding-left: 20px;
        }
        
        .size-warning-suggestions li {
            margin-bottom: 4px;
        }
        
        .results {
            margin-top: 30px;
            display: none;
        }
        
        .summary {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .match-item {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .match-item.collapsed {
            padding: 10px 15px;
        }
        
        .match-item.collapsed .match-content {
            display: none;
        }
        
        .match-header {
            font-weight: bold;
            color: #495057;
            margin-bottom: 10px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-radius: 3px;
            transition: background-color 0.2s;
        }
        
        .match-header:hover {
            background-color: #e9ecef;
            padding: 5px 10px;
        }
        
        .collapse-indicator {
            font-size: 14px;
            color: #6c757d;
            transition: transform 0.2s;
        }
        
        .match-item.collapsed .collapse-indicator {
            transform: rotate(-90deg);
        }
        
        .match-summary {
            font-size: 12px;
            color: #6c757d;
            font-weight: normal;
            margin-left: 10px;
        }
        
        .tensor-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .tensor-details {
            background-color: white;
            padding: 10px;
            border-radius: 3px;
            border-left: 4px solid #007bff;
        }
        
        .diff-stats {
            background-color: #fff3cd;
            padding: 10px;
            border-radius: 3px;
            border-left: 4px solid #ffc107;
            margin-bottom: 15px;
        }
        
        .error {
            color: #dc3545;
            background-color: #f8d7da;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
        }
        
        .plot-container {
            margin-top: 15px;
            min-height: 400px;
        }
        
        .shape-mismatch {
            background-color: #f8d7da;
            border-left-color: #dc3545;
        }
        
        .layer-group {
            margin-bottom: 30px;
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 20px;
            background-color: #f8f9fa;
        }
        
        .layer-group h3 {
            color: #007bff;
            margin-top: 0;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        
        .inspect-btn {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 10px 0;
        }
        
        .inspect-btn:hover {
            background-color: #218838;
        }
        
        .values-container {
            background-color: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
        }
        
        .slice-controls {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        
        .slider-group {
            margin-bottom: 15px;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #495057;
        }
        
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            margin: 5px 0;
        }
        
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .slider-group input[type="range"]::-webkit-slider-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #ddd;
            border-radius: 3px;
        }
        
        .slider-group input[type="range"]::-moz-range-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #ddd;
            border-radius: 3px;
            border: none;
        }
        
        .manual-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #dee2e6;
        }
        
        .manual-controls input[type="number"] {
            width: 80px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .manual-controls button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .manual-controls button:hover {
            background-color: #0056b3;
        }
        
        .slider-group span {
            color: #007bff;
            font-weight: bold;
            font-family: monospace;
        }
        
        .tensor-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .tensor-column h4 {
            background-color: #007bff;
            color: white;
            padding: 8px 12px;
            margin: 0 0 10px 0;
            border-radius: 3px;
        }
        
        .values-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 2px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            padding: 5px;
            background-color: #fafafa;
        }
        
        .value-cell {
            background-color: white;
            padding: 6px 8px;
            border: 1px solid #eee;
            border-radius: 2px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            text-align: right;
            cursor: help;
        }
        
        .value-cell:hover {
            background-color: #e3f2fd;
        }
        
        .tensor-info-display {
            background-color: #f1f3f4;
            padding: 10px;
            margin-top: 15px;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }
        
        .summary-stats {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .summary-stats h5 {
            margin: 0 0 10px 0;
            color: #495057;
            font-weight: bold;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #e9ecef;
        }
        
        .stat-item.highlight {
            background-color: #fff3cd;
            border-color: #ffeaa7;
            font-weight: bold;
        }
        
        .stat-label {
            color: #495057;
            font-size: 14px;
        }
        
        .stat-value {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #2c3e50;
            font-weight: bold;
        }
        
        .summary-stats.error {
            background-color: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }
        
        .summary-stats.single-model {
            background-color: #fff3cd;
            border-color: #ffc107;
        }
        
        .single-model-note {
            text-align: center;
            font-style: italic;
            color: #856404;
            margin-top: 10px;
            padding: 5px;
            background-color: #ffeaa7;
            border-radius: 3px;
        }
        
        .tensor-details.missing {
            background-color: #f8f9fa;
            color: #6c757d;
            font-style: italic;
        }
        
        .tensor-details.single-tensor {
            background-color: #d4edda;
            border-left-color: #28a745;
        }
        
        .missing-column {
            background-color: #f8f9fa;
            opacity: 0.6;
        }
        
        .missing-notice {
            padding: 20px;
            text-align: center;
            color: #6c757d;
            font-style: italic;
            background-color: #e9ecef;
            border-radius: 3px;
            margin: 10px;
        }
        
        .floating-header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: linear-gradient(135deg, #007bff, #28a745);
            color: white;
            padding: 10px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: none;
            border-radius: 0 0 8px 8px;
            margin-bottom: 20px;
        }
        
        .floating-header.visible {
            display: block;
        }
        
        .header-content {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            gap: 20px;
        }
        
        .model-info {
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            background: rgba(255,255,255,0.1);
            padding: 5px 10px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .model-info.model1 {
            text-align: left;
        }
        
        .model-info.model2 {
            text-align: right;
        }
        
        .vs-divider {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            color: #ffd700;
        }
        
        /* Upload Mode Selector Styles */
        .upload-mode-selector {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .mode-tabs {
            display: inline-flex;
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .mode-tab {
            background: none;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.2s ease;
            margin: 0 2px;
        }
        
        .mode-tab:hover {
            background-color: #e9ecef;
            color: #495057;
        }
        
        .mode-tab.active {
            background-color: #007bff;
            color: white;
            box-shadow: 0 2px 4px rgba(0, 123, 255, 0.3);
        }
        
        .single-file-zone {
            max-width: 500px;
            margin: 0 auto;
        }
        
        .upload-description {
            margin-top: 10px;
            font-size: 14px;
            color: #6c757d;
        }
        
        .upload-description em {
            color: #007bff;
        }
        
        /* Results Controls */
        .results-controls {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .control-row {
            display: flex;
            gap: 30px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-group label {
            font-weight: 600;
            color: #495057;
            min-width: 70px;
        }
        
        .control-group select {
            padding: 6px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            background: white;
            min-width: 150px;
        }
        
        .control-group input[type="checkbox"] {
            margin: 0 5px 0 15px;
        }
        
        .drag-info {
            color: #6c757d;
            font-size: 14px;
            text-align: center;
            padding: 8px;
            background: #e9ecef;
            border-radius: 4px;
        }
        
        /* Drag handle for matches */
        .drag-handle {
            cursor: grab;
            color: #6c757d;
            font-size: 16px;
            padding: 5px;
            margin-right: 10px;
            user-select: none;
        }
        
        .drag-handle:hover {
            color: #495057;
        }
        
        .drag-handle:active {
            cursor: grabbing;
        }
        
        /* Make match items draggable */
        .match-item {
            transition: transform 0.2s ease;
        }
        
        .match-item:hover .drag-handle {
            color: #007bff;
        }
        
        .sortable-ghost {
            opacity: 0.5;
            background: #e3f2fd;
        }
        
        .sortable-chosen {
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .view-values-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .view-values-btn:hover {
            background-color: #0056b3;
        }
        
        .inspect-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        
        .inspect-btn:hover {
            opacity: 0.9;
        }
        
        .upload-instructions {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .upload-instructions p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ML Model Tensor Debugger</h1>
        
        <!-- Smart Upload Instructions -->
        <div class="upload-instructions">
            <p><strong>Two upload modes (auto-detected):</strong></p>
            <p>📦 <em>Archives (.zip, .tar.gz)</em> → Compare two model archives</p>
            <p>📄 <em>Tensor files (.pth, .pt)</em> → Compare two tensor files directly</p>
        </div>
        
        <!-- Two-Box Upload Interface -->
        <div class="upload-section">
            <div class="drop-zone" id="file1-drop">
                <input type="file" id="file1" accept=".zip,.tar.gz,.tgz,.pth,.pt">
                <div class="drop-zone-text">Drop File 1 here</div>
                <div class="file-info" id="file1-info"></div>
            </div>
            <div class="drop-zone" id="file2-drop">
                <input type="file" id="file2" accept=".zip,.tar.gz,.tgz,.pth,.pt">
                <div class="drop-zone-text">Drop File 2 here</div>
                <div class="file-info" id="file2-info"></div>
            </div>
        </div>
        
        <button class="upload-btn" id="upload-btn" disabled>Process Files</button>
        
        <div class="size-warning" id="size-warning">
            <div class="size-warning-title">Large File Upload Detected</div>
            <div class="size-warning-text">
                Your upload is larger than 25MB. For better performance and reliability, consider:
                <ul class="size-warning-suggestions">
                    <li><strong>Split archives:</strong> Create smaller ZIP/TAR files with fewer tensor files</li>
                    <li><strong>Remove unnecessary files:</strong> Only include the tensor files you need to compare</li>
                    <li><strong>Use compression:</strong> Ensure your archives are properly compressed</li>
                    <li><strong>Upload individual .pth files:</strong> Use dual .pth mode instead of archives</li>
                </ul>
                <small><em>Large uploads may be slower and more prone to network timeouts.</em></small>
            </div>
        </div>
        
        <div class="progress" id="progress">
            <div class="progress-bar" id="progress-bar"></div>
            <div class="progress-text" id="progress-text">Preparing upload...</div>
        </div>
        
        <div class="results" id="results">
            <div class="floating-header" id="floating-header">
                <div class="header-content">
                    <div class="model-info model1" id="floating-model1">Model 1</div>
                    <div class="vs-divider">VS</div>
                    <div class="model-info model2" id="floating-model2">Model 2</div>
                </div>
            </div>
            <div class="summary" id="summary"></div>
            
            <!-- Results Controls for reordering, grouping, and filtering -->
            <div class="results-controls" id="results-controls" style="display: none;">
                <div class="control-row">
                    <div class="control-group">
                        <label>Group by:</label>
                        <select id="group-by" onchange="regroupMatches()">
                            <option value="layer">Layer (default)</option>
                            <option value="name">Filename</option>
                            <option value="similarity">Similarity</option>
                            <option value="none">No grouping</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label>Sort by:</label>
                        <select id="sort-by" onchange="resortMatches()">
                            <option value="layer_stage">Layer + Stage</option>
                            <option value="name">Alphabetical</option>
                            <option value="similarity">Best Match First</option>
                            <option value="difference">Largest Diff First</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label>Show:</label>
                        <input type="checkbox" id="show-identical" checked onchange="filterMatches()"> Identical
                        <input type="checkbox" id="show-different" checked onchange="filterMatches()"> Different  
                        <input type="checkbox" id="show-errors" checked onchange="filterMatches()"> Errors
                    </div>
                </div>
                <div class="drag-info">
                    💡 <em>Drag matches by the ⋮⋮ handle to reorder manually</em>
                </div>
            </div>
            
            <div style="text-align: center; margin: 20px 0; display: none;" id="control-buttons">
                <button class="upload-btn" onclick="collapseAll()" style="background-color: #6c757d;">
                    📉 Collapse All
                </button>
                <button class="upload-btn" onclick="expandAll()" style="background-color: #28a745; margin-left: 10px;">
                    📈 Expand All
                </button>
            </div>
            <div id="matches-container"></div>
        </div>
    </div>

    <script>
        let file1 = null;
        let file2 = null;
        let detectedMode = null;
        
        // Setup drag and drop
        function setupDropZone(dropZoneId, fileInputId, infoId) {
            const dropZone = document.getElementById(dropZoneId);
            const fileInput = document.getElementById(fileInputId);
            const fileInfo = document.getElementById(infoId);
            
            dropZone.addEventListener('click', () => fileInput.click());
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    // Directly call the new logic
                    handleFileSelectNew(file, dropZoneId, fileInput, fileInfo);
                }
            });
            
            fileInput.addEventListener('change', () => {
                handleFileSelect(fileInput, dropZone, fileInfo);
            });
        }
        
        function handleFileSelect(fileInput, dropZone, fileInfo) {
            const file = fileInput.files[0];
            if (file) {
                // Call the new handleFileSelect logic
                handleFileSelectNew(file, dropZone.id, fileInput, fileInfo);
            }
        }
        
        function handleFileSelectNew(file, dropZoneId, fileInput, fileInfo) {
            // Store the file
            if (dropZoneId === 'file1-drop') {
                file1 = file;
            } else if (dropZoneId === 'file2-drop') {
                file2 = file;
            }
            
            // Update UI
            const dropZone = document.getElementById(dropZoneId);
            dropZone.classList.add('file-loaded');
            
            // Detect file type and show appropriate info
            const isArchive = file.name.match(/\.(zip|tar\.gz|tgz)$/i);
            const isPth = file.name.match(/\.(pth|pt)$/i);
            const isSafetensors = file.name.match(/\.safetensors$/i);
            
            let fileTypeIcon = '';
            if (isArchive) {
                fileTypeIcon = '📦 ';
            } else if (isPth) {
                fileTypeIcon = '📄 ';
            } else if (isSafetensors) {
                fileTypeIcon = '🔒 ';
            }
            
            fileInfo.innerHTML = `${fileTypeIcon}<strong>${file.name}</strong><br>Size: ${formatFileSize(file.size)}`;
            
            // Update detected mode and button
            updateDetectedMode();
            updateUploadButton();
            
            // Check file sizes immediately when files are selected
            checkFileSizesAndShowWarning();
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function updateUploadButton() {
            const uploadBtn = document.getElementById('upload-btn');
            
            if (detectedMode === 'dual-archive' && file1 && file2) {
                uploadBtn.disabled = false;
                if (uploadBtn) uploadBtn.textContent = 'Compare Models';
            } else if (detectedMode === 'dual-pth' && file1 && file2) {
                uploadBtn.disabled = false;
                // Check if both are safetensors files
                const bothSafetensors = file1.name.match(/\.safetensors$/i) && file2.name.match(/\.safetensors$/i);
                const bothPth = file1.name.match(/\.(pth|pt)$/i) && file2.name.match(/\.(pth|pt)$/i);
                
                if (bothSafetensors) {
                    if (uploadBtn) uploadBtn.textContent = 'Compare SafeTensors';
                } else if (bothPth) {
                    if (uploadBtn) uploadBtn.textContent = 'Compare PyTorch Tensors';
                } else {
                    if (uploadBtn) uploadBtn.textContent = 'Compare Tensor Files';
                }
            } else {
                uploadBtn.disabled = true;
                if (uploadBtn) uploadBtn.textContent = 'Process Files';
            }
        }
        
        function checkFileSizesAndShowWarning() {
            const SIZE_LIMIT = 25 * 1024 * 1024; // 25MB in bytes
            
            // Only check if we have both files
            if (file1 && file2) {
                const totalSize = file1.size + file2.size;
                
                if (totalSize > SIZE_LIMIT) {
                    showSizeWarning(totalSize);
                } else {
                    hideSizeWarning();
                }
            } else {
                // Hide warning if we don't have both files yet
                hideSizeWarning();
            }
        }
        
        function showSizeWarning(totalSize) {
            const warning = document.getElementById('size-warning');
            const sizeText = formatFileSize(totalSize);
            
            // Update the warning message with the actual file size
            const warningText = warning.querySelector('.size-warning-text');
            
            // Add file size info
            const sizeInfo = `<div style="margin-bottom: 10px; font-weight: bold; color: #d39e00;">Total size: ${sizeText} (exceeds 25MB recommended limit)</div>`;
            const baseMessage = `
                <div style="margin-bottom: 10px;"><strong>You can still upload these files</strong>, but for better performance consider:</div>
                <ul class="size-warning-suggestions">
                    <li><strong>Split archives:</strong> Create smaller ZIP/TAR files with fewer tensor files</li>
                    <li><strong>Remove unnecessary files:</strong> Only include the tensor files you need to compare</li>
                    <li><strong>Use compression:</strong> Ensure your archives are properly compressed</li>
                    <li><strong>Upload individual .pth files:</strong> Use dual .pth mode instead of archives</li>
                </ul>
                <small><em>Large uploads use chunked transfer and may take longer to complete.</em></small>
            `;
            
            warningText.innerHTML = sizeInfo + baseMessage;
            warning.style.display = 'block';
        }
        
        function hideSizeWarning() {
            const warning = document.getElementById('size-warning');
            warning.style.display = 'none';
        }
        
        
        function showProgress() {
            document.getElementById('progress').style.display = 'block';
            document.getElementById('progress-bar').style.width = '0%';
        }
        
        function hideProgress() {
            document.getElementById('progress').style.display = 'none';
        }
        
        function updateProgress(percent, text = null) {
            const progressBar = document.getElementById('progress-bar');
            progressBar.style.width = percent + '%';
            progressBar.setAttribute('data-percentage', Math.round(percent) + '%');
            
            if (text) {
                const progressTextElement = document.getElementById('progress-text');
                if (progressTextElement) {
                    progressTextElement.textContent = text;
                }
            }
        }
        
        async function uploadAndCompare() {
            showProgress();
            updateProgress(5);
            
            // Determine upload mode and files
            const files = [];
            const fileNames = [];
            let uploadMode = 'dual_archive';
            
            if (currentMode === 'dual-archive') {
                if (!model1File || !model2File) {
                    alert('Please select both files');
                    hideProgress();
                    return;
                }
                files.push(model1File, model2File);
                fileNames.push(model1File.name, model2File.name);
                uploadMode = 'dual_archive';
            } else if (currentMode === 'dual-pth') {
                if (!model1File || !model2File) {
                    alert('Please select both .pth files');
                    hideProgress();
                    return;
                }
                files.push(model1File, model2File);
                fileNames.push(model1File.name, model2File.name);
                uploadMode = 'dual_pth';
            } else if (currentMode === 'single-file') {
                if (!singleFile) {
                    alert('Please select a .pth file');
                    hideProgress();
                    return;
                }
                files.push(singleFile);
                fileNames.push(singleFile.name);
                uploadMode = 'single_file';
            }
            
            try {
                // Use chunked upload for all files
                const result = await uploadFilesInChunks(files, fileNames, uploadMode);
                updateProgress(98, 'Displaying results...');
                
                if (result.error) {
                    throw new Error(result.error);
                }
                
                await displayResults(result);
                updateProgress(100, 'Complete!');
                
                setTimeout(hideProgress, 500);
                
            } catch (error) {
                hideProgress();
                document.getElementById('results').innerHTML = 
                    `<div class="error">Error: ${error.message}</div>`;
                document.getElementById('results').style.display = 'block';
            }
        }
        
        async function uploadFilesInChunks(files, fileNames, uploadMode) {
            const CHUNK_SIZE = 1024 * 1024; // 1MB chunks
            
            // Calculate total chunks for all files
            const totalChunks = Math.max(...files.map(file => Math.ceil(file.size / CHUNK_SIZE)));
            
            updateProgress(10, 'Initializing upload session...');
            
            // Start chunked upload session
            const sessionResponse = await fetch('/start_chunked_upload', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    total_chunks: totalChunks,
                    file_names: fileNames
                })
            });
            
            const sessionData = await sessionResponse.json();
            if (sessionData.error) {
                throw new Error(sessionData.error);
            }
            
            const sessionId = sessionData.session_id;
            updateProgress(15, 'Upload session created, starting file upload...');
            
            // Calculate total chunks across all files for accurate progress
            const totalChunksAllFiles = files.reduce((sum, file) => 
                sum + Math.ceil(file.size / CHUNK_SIZE), 0);
            let completedChunks = 0;
            
            // Upload files sequentially to better track progress
            for (let fileIndex = 0; fileIndex < files.length; fileIndex++) {
                const file = files[fileIndex];
                const fileName = fileNames[fileIndex];
                const fileChunks = Math.ceil(file.size / CHUNK_SIZE);
                
                updateProgress(15 + (completedChunks / totalChunksAllFiles) * 70, 
                    `Starting upload of ${fileName}...`);
                
                // Upload chunks for this file
                for (let chunkIndex = 0; chunkIndex < fileChunks; chunkIndex++) {
                    const start = chunkIndex * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE, file.size);
                    const chunk = file.slice(start, end);
                    
                    const formData = new FormData();
                    formData.append('session_id', sessionId);
                    formData.append('file_name', fileName);
                    formData.append('chunk_index', chunkIndex.toString());
                    formData.append('chunk', chunk);
                    
                    const chunkResponse = await fetch('/upload_chunk', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const chunkResult = await chunkResponse.json();
                    if (chunkResult.error) {
                        throw new Error(chunkResult.error);
                    }
                    
                    completedChunks++;
                    
                    // Update progress based on total chunks completed
                    const overallProgress = 15 + (completedChunks / totalChunksAllFiles) * 70;
                    const progressText = `Uploading ${fileName} - chunk ${chunkIndex + 1}/${fileChunks} (${Math.round(overallProgress)}%)`;
                    updateProgress(Math.floor(overallProgress), progressText);
                    
                    // Small delay to make progress visible for fast uploads
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                updateProgress(15 + (completedChunks / totalChunksAllFiles) * 70, 
                    `Completed ${fileName} (${completedChunks}/${totalChunksAllFiles} chunks)`);
            }
            updateProgress(85, 'All chunks uploaded, verifying completion...');
            
            // Monitor progress until all files are complete
            await monitorUploadProgress(sessionId);
            updateProgress(90, 'Upload complete, processing tensor files...');
            
            // Complete the upload and process files
            const completeResponse = await fetch('/complete_chunked_upload', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    session_id: sessionId,
                    upload_mode: uploadMode
                })
            });
            
            const result = await completeResponse.json();
            updateProgress(95, 'Tensor processing complete, preparing results...');
            
            return result;
        }
        
        async function monitorUploadProgress(sessionId) {
            let allComplete = false;
            let lastProgress = 85;
            
            while (!allComplete) {
                try {
                    const progressResponse = await fetch(`/get_upload_progress/${sessionId}`);
                    const progressData = await progressResponse.json();
                    
                    if (progressData.error) {
                        throw new Error(progressData.error);
                    }
                    
                    // Check if all files are complete
                    allComplete = Object.values(progressData).every(fileProgress => fileProgress.completed);
                    
                    if (!allComplete) {
                        // Show verification progress
                        const completedFiles = Object.values(progressData).filter(fp => fp.completed).length;
                        const totalFiles = Object.keys(progressData).length;
                        const verifyProgress = 85 + (5 * completedFiles / totalFiles);
                        
                        if (verifyProgress > lastProgress) {
                            updateProgress(Math.floor(verifyProgress), 
                                `Verifying uploads... ${completedFiles}/${totalFiles} files complete`);
                            lastProgress = verifyProgress;
                        }
                        
                        // Wait before checking again
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                } catch (error) {
                    console.warn('Progress check failed:', error);
                    // Continue monitoring even if one check fails
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
        }
        
        let globalMatches = []; // Store matches globally for tensor inspection

        async function displayResults(data) {
            const resultsDiv = document.getElementById('results');
            const summaryDiv = document.getElementById('summary');
            const matchesContainer = document.getElementById('matches-container');
            const floatingHeader = document.getElementById('floating-header');
            const floatingModel1 = document.getElementById('floating-model1');
            const floatingModel2 = document.getElementById('floating-model2');
            
            globalMatches = data.matches;
            
            // Update floating header with model names
            let model1Name, model2Name;
            if (data.upload_mode === 'single_file') {
                model1Name = 'Single File';
                model2Name = 'Self-Comparison';
            } else if (data.upload_mode === 'dual_pth') {
                model1Name = 'File 1';
                model2Name = 'File 2';
            } else {
                model1Name = file1 ? file1.name : 'Model 1';
                model2Name = file2 ? file2.name : 'Model 2';
            }
            if (floatingModel1) floatingModel1.textContent = model1Name;
            if (floatingModel2) floatingModel2.textContent = model2Name;
            floatingHeader.classList.add('visible');
            
            if (data.upload_mode === 'single_file') {
                summaryDiv.innerHTML = `
                    <h3>Single File Tensor Exploration</h3>
                    <p>File: ${model1Name}</p>
                    <p>Total tensors: ${data.model1_files}</p>
                    <p>Pairwise comparisons: ${data.matches.length}</p>
                    <p><em>Comparing all tensor pairs within the same file</em></p>
                `;
            } else if (data.upload_mode === 'dual_pth') {
                summaryDiv.innerHTML = `
                    <h3>Direct Tensor File Comparison</h3>
                    <p>File 1: ${model1Name} (${data.model1_files} tensors)</p>
                    <p>File 2: ${model2Name} (${data.model2_files} tensors)</p>
                    <p>Tensor comparisons: <strong>${data.matches.length}</strong></p>
                    <p><em>Direct comparison of .pth tensor files</em></p>
                    <div style="margin-top: 15px; padding: 10px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; color: #856404;">
                        <strong>⚠️ Known Issue:</strong> .pth file comparisons are experimental and may be buggy. 
                        Some features may not work correctly or may cause unexpected behavior. 
                        For most reliable results, use archive comparisons instead.
                    </div>
                `;
            } else {
                summaryDiv.innerHTML = `
                    <h3>Model Archive Comparison</h3>
                    <p>Model 1: ${data.model1_files} tensor files (${model1Name})</p>
                    <p>Model 2: ${data.model2_files} tensor files (${model2Name})</p>
                    <p>Matched pairs: ${data.matches.length}</p>
                `;
            }
            
            matchesContainer.innerHTML = '';
            
            // Handle dual .pth files - use same interface as archive mode for consistency
            if (data.upload_mode === 'dual_pth') {
                // Direct tensor comparison - show all matches in one simple group
                const tensorSection = document.createElement('div');
                tensorSection.className = 'layer-section';
                tensorSection.id = 'tensor-comparisons';
                
                const sectionTitle = document.createElement('h3');
                sectionTitle.className = 'layer-title';
                sectionTitle.textContent = `Tensor Comparisons (${data.matches.length} pairs)`;
                tensorSection.appendChild(sectionTitle);
                
                data.matches.forEach((match, index) => {
                    match.match_index = index; // Ensure proper indexing
                    
                    // Create match element directly for dual .pth
                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'match-item collapsed'; // Start collapsed
                    matchDiv.dataset.matchIndex = match.match_index;
                    
                    // Generate summary for tensor comparison
                    let quickSummary = '';
                    if (match.diff_stats && !match.diff_stats.error) {
                        quickSummary = `<span class="match-summary">Max Diff: ${match.diff_stats.abs_diff_max.toFixed(6)}, Cosine Sim: ${match.diff_stats.cosine_sim.toFixed(4)}</span>`;
                    } else if (match.diff_stats && match.diff_stats.error) {
                        quickSummary = `<span class="match-summary">Error: ${match.diff_stats.error}</span>`;
                    }

                    matchDiv.innerHTML = `
                        <div class="match-header" onclick="toggleMatch(${match.match_index})">
                            <div style="display: flex; align-items: center;">
                                <span class="drag-handle" onclick="event.stopPropagation()">⋮⋮</span>
                                <div>
                                    <span>${match.stage_display}</span>
                                    ${quickSummary}
                                </div>
                            </div>
                            <span class="collapse-indicator">▼</span>
                        </div>
                        <div class="match-content">
                            <div class="tensor-info">
                                <div class="tensor-details">
                                    <strong>File 1:</strong> ${match.model1_file}<br>
                                    Shape: [${match.model1_data.shape.join(', ')}]
                                </div>
                                <div class="tensor-details">
                                    <strong>File 2:</strong> ${match.model2_file}<br>
                                    Shape: [${match.model2_data.shape.join(', ')}]
                                </div>
                            </div>
                            ${match.diff_stats && !match.diff_stats.error ? `
                            <div class="summary-stats">
                                <h5>Summary Statistics</h5>
                                <div class="stats-grid">
                                    <div class="stat-item">
                                        <span class="stat-label">Model 1 Mean:</span>
                                        <span class="stat-value">${match.model1_data.mean.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 2 Mean:</span>
                                        <span class="stat-value">${match.model2_data.mean.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 1 Std:</span>
                                        <span class="stat-value">${match.model1_data.std.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 2 Std:</span>
                                        <span class="stat-value">${match.model2_data.std.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item highlight">
                                        <span class="stat-label">Max Difference:</span>
                                        <span class="stat-value">${match.diff_stats.abs_diff_max.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item highlight">
                                        <span class="stat-label">Cosine Similarity:</span>
                                        <span class="stat-value">${match.diff_stats.cosine_sim.toFixed(6)}</span>
                                    </div>
                                </div>
                            </div>
                            ` : ''}
                            <div class="tensor-values">
                                <button class="inspect-btn" onclick="showTensorValues(${match.match_index})">
                                    Inspect Raw Tensor Values
                                </button>
                                ${match.diff_stats && !match.diff_stats.error ? `<button class="inspect-btn" onclick="jumpToMaxDiffInTensor(${match.match_index})" style="background-color: #dc3545; margin-left: 10px;">🎯 Jump to Max Diff</button>` : ''}
                                ${match.diff_stats && !match.diff_stats.error ? `<button class="inspect-btn" onclick="quickManualMapping(${match.match_index})" style="background-color: #17a2b8; margin-left: 10px;">🔧 Manual Mapping</button>` : ''}
                                
                                <!-- Full tensor inspection interface (reuse from archive mode) -->
                                <div class="values-container" id="values-${match.match_index}" style="display: none;">
                                    
                                    <!-- Dimension Mapping Controls -->
                                    <div class="dimension-mapping" id="dimension-mapping-${match.match_index}" style="display: none; margin-bottom: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 5px;">
                                        <h4>Manual Dimension Mapping</h4>
                                        <p>Control which dimensions to slice for each tensor independently:</p>
                                        <div id="mapping-controls-${match.match_index}"></div>
                                        <button onclick="applyDimensionMapping(${match.match_index})" style="margin-top: 10px; background-color: #28a745;">Apply Mapping</button>
                                        <button onclick="toggleMappingMode(${match.match_index})" style="margin-top: 10px; margin-left: 10px; background-color: #6c757d;">Switch to Auto Mode</button>
                                    </div>
                                    
                                    <!-- Original slice controls -->
                                    <div class="slice-controls" id="auto-controls-${match.match_index}">
                                        <div id="dimension-controls-${match.match_index}"></div>
                                        <div class="slider-group">
                                            <label for="count-slider-${match.match_index}">Values to Show: <span id="count-value-${match.match_index}">10</span></label>
                                            <input type="range" id="count-slider-${match.match_index}" min="1" max="100" value="10" 
                                                   oninput="updateSliderValue(${match.match_index}, 'count')" 
                                                   onchange="updateTensorValues(${match.match_index})">
                                        </div>
                                        <div class="manual-controls">
                                            <input type="number" id="count-input-${match.match_index}" value="10" min="1" max="100" 
                                                   onchange="syncSliderFromInput(${match.match_index}, 'count')" placeholder="Count">
                                            <button onclick="updateTensorValues(${match.match_index})">Update</button>
                                        </div>
                                        
                                        <!-- Real-time statistics display -->
                                        <div class="real-time-stats" id="real-time-stats-${match.match_index}" style="margin-top: 15px; padding: 10px; background-color: #e3f2fd; border-radius: 5px;">
                                            <h6>Real-time Slice Statistics</h6>
                                            <div id="slice-stats-${match.match_index}">
                                                <!-- Populated by updateTensorValues -->
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Tensor values display -->
                                    <div id="tensor-display-${match.match_index}"></div>
                                </div>
                            </div>
                        </div>
                        </div>
                    `;
                    
                    tensorSection.appendChild(matchDiv);
                });
                
                matchesContainer.appendChild(tensorSection);
            } else {
                // Group matches by layer for archive comparisons
                const layerGroups = {};
                data.matches.forEach((match, index) => {
                    if (!layerGroups[match.layer_num]) {
                        layerGroups[match.layer_num] = [];
                    }
                    layerGroups[match.layer_num].push({...match, match_index: index});
                });
                
                // Display each layer group
                Object.keys(layerGroups).sort((a, b) => parseInt(a) - parseInt(b)).forEach(layerNum => {
                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer-group';
                layerDiv.innerHTML = `<h3>Layer ${layerNum}</h3>`;
                
                layerGroups[layerNum].forEach(match => {
                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'match-item collapsed'; // Start collapsed by default
                    matchDiv.setAttribute('data-match-index', match.match_index);
                    
                    // Generate summary statistics display
                    let summaryContent = '';
                    
                    if (match.match_type === 'both' && match.diff_stats && !match.diff_stats.error) {
                        if (match.diff_stats.shape_match) {
                            // Check if this looks like a potential manual mapping case
                            let manualMappingHint = '';
                            if (match.model1_data && match.model2_data) {
                                const shape1 = match.model1_data.shape;
                                const shape2 = match.model2_data.shape;
                                const elements1 = shape1.reduce((a, b) => a * b, 1);
                                const elements2 = shape2.reduce((a, b) => a * b, 1);
                                
                                // Check if shapes are very different but same elements AND poor similarity
                                const shapesDifferent = JSON.stringify(shape1) !== JSON.stringify(shape2);
                                const poorSimilarity = match.diff_stats.cosine_sim < 0.5;
                                const highDifference = match.diff_stats.abs_diff_max > 1.0;
                                
                                if (elements1 === elements2 && shapesDifferent && (poorSimilarity || highDifference)) {
                                    manualMappingHint = `
                                        <div style="margin-top: 10px; padding: 8px; background-color: #e3f2fd; border-radius: 4px; color: #1565c0; border-left: 4px solid #2196f3;">
                                            💡 <strong>Manual Mapping Recommended:</strong> These tensors have identical element counts (${elements1}) but very different shapes and poor similarity. 
                                            The automatic reshaping may not be finding the correct alignment. 
                                            <strong>Try "🔧 Manual Mapping"</strong> to manually explore dimension combinations!
                                        </div>
                                    `;
                                }
                            }
                            
                            summaryContent = `
                                <div class="summary-stats">
                                    <h5>Summary Statistics</h5>
                                    <div class="stats-grid">
                                        <div class="stat-item">
                                            <span class="stat-label">Model 1 Mean:</span>
                                            <span class="stat-value">${match.model1_data.mean.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Model 2 Mean:</span>
                                            <span class="stat-value">${match.model2_data.mean.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Model 1 Std:</span>
                                            <span class="stat-value">${match.model1_data.std.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Model 2 Std:</span>
                                            <span class="stat-value">${match.model2_data.std.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item highlight">
                                            <span class="stat-label">Max Difference:</span>
                                            <span class="stat-value">${match.diff_stats.abs_diff_max.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item highlight">
                                            <span class="stat-label">Cosine Similarity:</span>
                                            <span class="stat-value">${match.diff_stats.cosine_sim.toFixed(6)}</span>
                                        </div>
                                    </div>
                                    ${manualMappingHint}
                                </div>
                            `;
                        } else {
                            summaryContent = `
                                <div class="summary-stats error">
                                    <strong>Shape Mismatch:</strong><br>
                                    Model 1: [${match.diff_stats.shape1.join(', ')}]<br>
                                    Model 2: [${match.diff_stats.shape2.join(', ')}]<br>
                                    <em>${match.diff_stats.error || 'Cannot reshape for tensor parallel compatibility'}</em>
                                </div>
                            `;
                        }
                    } else if (match.match_type === 'model1_only') {
                        summaryContent = `
                            <div class="summary-stats single-model">
                                <h5>Single Model Statistics</h5>
                                <div class="stats-grid">
                                    <div class="stat-item">
                                        <span class="stat-label">Model 1 Mean:</span>
                                        <span class="stat-value">${match.model1_data.mean.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 1 Std:</span>
                                        <span class="stat-value">${match.model1_data.std.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 1 Min:</span>
                                        <span class="stat-value">${match.model1_data.min.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 1 Max:</span>
                                        <span class="stat-value">${match.model1_data.max.toFixed(6)}</span>
                                    </div>
                                </div>
                                <div class="single-model-note">⚠️ Only available in Model 1</div>
                            </div>
                        `;
                    } else if (match.match_type === 'model2_only') {
                        summaryContent = `
                            <div class="summary-stats single-model">
                                <h5>Single Model Statistics</h5>
                                <div class="stats-grid">
                                    <div class="stat-item">
                                        <span class="stat-label">Model 2 Mean:</span>
                                        <span class="stat-value">${match.model2_data.mean.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 2 Std:</span>
                                        <span class="stat-value">${match.model2_data.std.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 2 Min:</span>
                                        <span class="stat-value">${match.model2_data.min.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 2 Max:</span>
                                        <span class="stat-value">${match.model2_data.max.toFixed(6)}</span>
                                    </div>
                                </div>
                                <div class="single-model-note">⚠️ Only available in Model 2</div>
                            </div>
                        `;
                    } else if (match.diff_stats && match.diff_stats.error) {
                        // Check if this might be a reshapeable tensor case
                        const hasReshapeHint = match.diff_stats.error && match.diff_stats.error.includes('reshape');
                        let reshapeHintText = '';
                        
                        if (hasReshapeHint && match.model1_data && match.model2_data) {
                            const shape1 = match.model1_data.shape;
                            const shape2 = match.model2_data.shape;
                            const elements1 = shape1.reduce((a, b) => a * b, 1);
                            const elements2 = shape2.reduce((a, b) => a * b, 1);
                            
                            if (elements1 === elements2) {
                                reshapeHintText = `
                                    <div style="margin-top: 10px; padding: 8px; background-color: #e3f2fd; border-radius: 4px; color: #1565c0; border-left: 4px solid #2196f3;">
                                        💡 <strong>Tip:</strong> These tensors have the same number of elements (${elements1}) but different shapes. 
                                        They might contain identical data arranged differently. 
                                        <strong>Try "🔧 Manual Mapping"</strong> to explore different dimension combinations!
                                    </div>
                                `;
                            }
                        }
                        
                        summaryContent = `
                            <div class="summary-stats error">
                                <strong>Error:</strong> ${match.diff_stats.error}
                                ${reshapeHintText}
                            </div>
                        `;
                    }

                    // Generate tensor info display based on match type
                    let tensorInfoContent = '';
                    if (match.match_type === 'both') {
                        tensorInfoContent = `
                            <div class="tensor-details">
                                <strong>Model 1:</strong> ${match.model1_file}<br>
                                Shape: [${match.model1_data.shape.join(', ')}]
                            </div>
                            <div class="tensor-details">
                                <strong>Model 2:</strong> ${match.model2_file}<br>
                                Shape: [${match.model2_data.shape.join(', ')}]
                            </div>
                        `;
                    } else if (match.match_type === 'model1_only') {
                        tensorInfoContent = `
                            <div class="tensor-details single-tensor">
                                <strong>Model 1:</strong> ${match.model1_file}<br>
                                Shape: [${match.model1_data.shape.join(', ')}]
                            </div>
                            <div class="tensor-details missing">
                                <strong>Model 2:</strong> <em>Not available</em>
                            </div>
                        `;
                    } else if (match.match_type === 'model2_only') {
                        tensorInfoContent = `
                            <div class="tensor-details missing">
                                <strong>Model 1:</strong> <em>Not available</em>
                            </div>
                            <div class="tensor-details single-tensor">
                                <strong>Model 2:</strong> ${match.model2_file}<br>
                                Shape: [${match.model2_data.shape.join(', ')}]
                            </div>
                        `;
                    }

                    // Create a summary for the collapsed view
                    let quickSummary = '';
                    if (match.match_type === 'both' && match.diff_stats && !match.diff_stats.error && match.diff_stats.shape_match) {
                        quickSummary = `<span class="match-summary">Max Diff: ${match.diff_stats.abs_diff_max.toFixed(6)}, Cosine Sim: ${match.diff_stats.cosine_sim.toFixed(4)}</span>`;
                    } else if (match.match_type !== 'both') {
                        quickSummary = `<span class="match-summary">Single model only</span>`;
                    } else if (match.diff_stats && match.diff_stats.error) {
                        quickSummary = `<span class="match-summary">Error: ${match.diff_stats.error}</span>`;
                    }

                    matchDiv.innerHTML = `
                        <div class="match-header" onclick="toggleMatch(${match.match_index})">
                            <div style="display: flex; align-items: center;">
                                <span class="drag-handle" onclick="event.stopPropagation()">⋮⋮</span>
                                <div>
                                    <span>${match.stage_display}</span>
                                    ${quickSummary}
                                </div>
                            </div>
                            <span class="collapse-indicator">▼</span>
                        </div>
                        <div class="match-content">
                            <div class="tensor-info">
                                ${tensorInfoContent}
                            </div>
                            ${summaryContent}
                            <div class="tensor-values">
                                <button class="inspect-btn" onclick="showTensorValues(${match.match_index})">
                                    Inspect Raw Tensor Values
                                </button>
                                ${match.match_type === 'both' ? `<button class="inspect-btn" onclick="jumpToMaxDiffInTensor(${match.match_index})" style="background-color: #dc3545; margin-left: 10px;">🎯 Jump to Max Diff</button>` : ''}
                                ${match.match_type === 'both' ? `<button class="inspect-btn" onclick="quickManualMapping(${match.match_index})" style="background-color: #17a2b8; margin-left: 10px;">🔧 Manual Mapping</button>` : ''}
                                <div class="values-container" id="values-${match.match_index}" style="display: none;">
                                    
                                    <!-- Dimension Mapping Controls -->
                                    <div class="dimension-mapping" id="dimension-mapping-${match.match_index}" style="display: none; margin-bottom: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 5px;">
                                        <h4>Manual Dimension Mapping</h4>
                                        <p>Control which dimensions to slice for each tensor independently:</p>
                                        <div id="mapping-controls-${match.match_index}"></div>
                                        <button onclick="applyDimensionMapping(${match.match_index})" style="margin-top: 10px; background-color: #28a745;">Apply Mapping</button>
                                        <button onclick="toggleMappingMode(${match.match_index})" style="margin-top: 10px; margin-left: 10px; background-color: #6c757d;">Switch to Auto Mode</button>
                                    </div>
                                    
                                    <!-- Original slice controls -->
                                    <div class="slice-controls" id="auto-controls-${match.match_index}">
                                        <div id="dimension-controls-${match.match_index}"></div>
                                        <div class="slider-group">
                                            <label for="count-slider-${match.match_index}">Values to Show: <span id="count-value-${match.match_index}">10</span></label>
                                            <input type="range" id="count-slider-${match.match_index}" min="1" max="100" value="10" 
                                                   oninput="updateSliderValue(${match.match_index}, 'count')" 
                                                   onchange="updateTensorValues(${match.match_index})">
                                        </div>
                                        <div class="manual-controls">
                                            <input type="number" id="count-input-${match.match_index}" value="10" min="1" max="100" 
                                                   onchange="syncSliderFromInput(${match.match_index}, 'count')" placeholder="Count">
                                            <button onclick="updateTensorValues(${match.match_index})">Update</button>
                                            <button onclick="resetDimensionSliders(${match.match_index})" style="background-color: #6c757d; margin-left: 10px;">Reset</button>
                                            <button onclick="toggleMappingMode(${match.match_index})" style="background-color: #007bff; margin-left: 10px;">Manual Mapping</button>
                                        </div>
                                    </div>
                                    <div id="tensor-display-${match.match_index}"></div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    layerDiv.appendChild(matchDiv);
                });
                
                matchesContainer.appendChild(layerDiv);
                });
            } // Close the else block for archive mode
            
            resultsDiv.style.display = 'block';
            
            // Show the results controls and control buttons
            document.getElementById('results-controls').style.display = 'block';
            document.getElementById('control-buttons').style.display = 'block';
            
            // Initialize sortable functionality for drag-and-drop reordering
            initializeSortable();
        }
        
        // Drag and Drop + Reordering Functionality
        let sortableInstance = null;
        
        function initializeSortable() {
            const matchesContainer = document.getElementById('matches-container');
            
            if (sortableInstance) {
                sortableInstance.destroy();
            }
            
            sortableInstance = new Sortable(matchesContainer, {
                handle: '.drag-handle',
                animation: 150,
                ghostClass: 'sortable-ghost',
                chosenClass: 'sortable-chosen',
                onEnd: function(evt) {
                    updateMatchOrder(evt.oldIndex, evt.newIndex);
                }
            });
        }
        
        function updateMatchOrder(oldIndex, newIndex) {
            // Reorder globalMatches array
            const item = globalMatches.splice(oldIndex, 1)[0];
            globalMatches.splice(newIndex, 0, item);
            
            // Update match indices
            globalMatches.forEach((match, index) => {
                match.match_index = index;
            });
            
            console.log(`Moved match from position ${oldIndex} to ${newIndex}`);
            
            // Optionally sync with backend
            syncMatchOrderWithBackend(oldIndex, newIndex);
        }
        
        async function syncMatchOrderWithBackend(oldIndex, newIndex) {
            try {
                const response = await fetch('/reorder_matches', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        old_index: oldIndex,
                        new_index: newIndex
                    })
                });
                
                const result = await response.json();
                if (!result.success) {
                    console.warn('Backend reorder sync failed:', result.error);
                }
            } catch (error) {
                console.warn('Failed to sync match order with backend:', error);
            }
        }
        
        // Grouping and Filtering Functions
        function regroupMatches() {
            const groupBy = document.getElementById('group-by').value;
            console.log(`Regrouping matches by: ${groupBy}`);
            
            let groupedMatches = {};
            
            switch(groupBy) {
                case 'layer':
                    globalMatches.forEach(match => {
                        const key = `Layer ${match.layer_num}`;
                        if (!groupedMatches[key]) groupedMatches[key] = [];
                        groupedMatches[key].push(match);
                    });
                    break;
                    
                case 'name':
                    globalMatches.forEach(match => {
                        const key = match.stage || 'Unknown';
                        if (!groupedMatches[key]) groupedMatches[key] = [];
                        groupedMatches[key].push(match);
                    });
                    break;
                    
                case 'similarity':
                    globalMatches.forEach(match => {
                        let key = 'Unknown';
                        if (match.diff_stats && match.diff_stats.cosine_sim !== undefined) {
                            if (match.diff_stats.cosine_sim > 0.95) key = 'High Similarity (>95%)';
                            else if (match.diff_stats.cosine_sim > 0.8) key = 'Medium Similarity (80-95%)';
                            else key = 'Low Similarity (<80%)';
                        } else if (match.match_type !== 'both') {
                            key = 'Single Model Only';
                        }
                        if (!groupedMatches[key]) groupedMatches[key] = [];
                        groupedMatches[key].push(match);
                    });
                    break;
                    
                case 'none':
                    groupedMatches['All Matches'] = [...globalMatches];
                    break;
            }
            
            rerenderMatches(groupedMatches);
        }
        
        function resortMatches() {
            const sortBy = document.getElementById('sort-by').value;
            console.log(`Resorting matches by: ${sortBy}`);
            
            let sortedMatches = [...globalMatches];
            
            switch(sortBy) {
                case 'layer_stage':
                    sortedMatches.sort((a, b) => {
                        if (a.layer_num !== b.layer_num) return a.layer_num - b.layer_num;
                        return (a.stage_index || 0) - (b.stage_index || 0);
                    });
                    break;
                    
                case 'name':
                    sortedMatches.sort((a, b) => {
                        const nameA = (a.stage || a.model1_file || '').toLowerCase();
                        const nameB = (b.stage || b.model1_file || '').toLowerCase();
                        return nameA.localeCompare(nameB);
                    });
                    break;
                    
                case 'similarity':
                    sortedMatches.sort((a, b) => {
                        const simA = (a.diff_stats && a.diff_stats.cosine_sim !== undefined) ? a.diff_stats.cosine_sim : -1;
                        const simB = (b.diff_stats && b.diff_stats.cosine_sim !== undefined) ? b.diff_stats.cosine_sim : -1;
                        return simB - simA; // High similarity first
                    });
                    break;
                    
                case 'difference':
                    sortedMatches.sort((a, b) => {
                        const diffA = (a.diff_stats && a.diff_stats.abs_diff_max !== undefined) ? a.diff_stats.abs_diff_max : 0;
                        const diffB = (b.diff_stats && b.diff_stats.abs_diff_max !== undefined) ? b.diff_stats.abs_diff_max : 0;
                        return diffB - diffA; // Largest difference first
                    });
                    break;
            }
            
            globalMatches = sortedMatches;
            
            // Update match indices
            globalMatches.forEach((match, index) => {
                match.match_index = index;
            });
            
            // Regroup after sorting to maintain current grouping
            regroupMatches();
        }
        
        function filterMatches() {
            const showIdentical = document.getElementById('show-identical').checked;
            const showDifferent = document.getElementById('show-different').checked;
            const showErrors = document.getElementById('show-errors').checked;
            
            console.log(`Filtering matches: identical=${showIdentical}, different=${showDifferent}, errors=${showErrors}`);
            
            const matchDivs = document.querySelectorAll('[id^="match-layer-"]');
            matchDivs.forEach(layerDiv => {
                const matchItems = layerDiv.querySelectorAll('.match-item');
                let visibleMatches = 0;
                
                matchItems.forEach((matchDiv, index) => {
                    const matchData = globalMatches.find(m => m.match_index === parseInt(matchDiv.dataset.matchIndex));
                    if (!matchData) return;
                    
                    let shouldShow = false;
                    
                    if (matchData.diff_stats && matchData.diff_stats.error) {
                        shouldShow = showErrors;
                    } else if (matchData.match_type !== 'both') {
                        shouldShow = showDifferent; // Single model only counts as "different"
                    } else if (matchData.diff_stats) {
                        const isIdentical = matchData.diff_stats.abs_diff_max < 1e-6;
                        shouldShow = isIdentical ? showIdentical : showDifferent;
                    } else {
                        shouldShow = showDifferent;
                    }
                    
                    matchDiv.style.display = shouldShow ? 'block' : 'none';
                    if (shouldShow) visibleMatches++;
                });
                
                // Hide layer div if no matches are visible
                layerDiv.style.display = visibleMatches > 0 ? 'block' : 'none';
            });
        }
        
        function rerenderMatches(groupedMatches) {
            const matchesContainer = document.getElementById('matches-container');
            matchesContainer.innerHTML = '';
            
            Object.keys(groupedMatches).forEach(groupName => {
                const matches = groupedMatches[groupName];
                if (matches.length === 0) return;
                
                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer-section';
                layerDiv.id = `match-layer-${groupName.replace(/[^a-zA-Z0-9]/g, '-')}`;
                
                const layerTitle = document.createElement('h3');
                layerTitle.className = 'layer-title';
                layerTitle.textContent = `${groupName} (${matches.length} matches)`;
                layerDiv.appendChild(layerTitle);
                
                matches.forEach(match => {
                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'match-item';
                    matchDiv.dataset.matchIndex = match.match_index;
                    
                    // Generate quick summary
                    let quickSummary = '';
                    if (match.diff_stats && !match.diff_stats.error && match.match_type === 'both') {
                        quickSummary = `<span class="match-summary">Max Diff: ${match.diff_stats.abs_diff_max.toFixed(6)}, Cosine Sim: ${match.diff_stats.cosine_sim.toFixed(4)}</span>`;
                    } else if (match.match_type !== 'both') {
                        quickSummary = `<span class="match-summary">Single model only</span>`;
                    } else if (match.diff_stats && match.diff_stats.error) {
                        quickSummary = `<span class="match-summary">Error: ${match.diff_stats.error}</span>`;
                    }
                    
                    matchDiv.innerHTML = `
                        <div class="match-header" onclick="toggleMatch(${match.match_index})">
                            <div style="display: flex; align-items: center;">
                                <span class="drag-handle" onclick="event.stopPropagation()">⋮⋮</span>
                                <div>
                                    <span>${match.stage_display}</span>
                                    ${quickSummary}
                                </div>
                            </div>
                            <span class="collapse-indicator">▼</span>
                        </div>
                        <div class="match-content" style="display: none;">
                            <div class="tensor-info">
                                <!-- Content will be added when expanded -->
                            </div>
                        </div>
                    `;
                    
                    layerDiv.appendChild(matchDiv);
                });
                
                matchesContainer.appendChild(layerDiv);
            });
            
            // Reinitialize sortable after rerendering
            initializeSortable();
            
            // Apply current filters
            filterMatches();
        }
        
        async function showTensorValues(matchIndex) {
            console.log(`showTensorValues called for matchIndex: ${matchIndex}`);
            const valuesContainer = document.getElementById(`values-${matchIndex}`);
            console.log(`valuesContainer:`, valuesContainer);
            
            if (valuesContainer.style.display === 'none') {
                valuesContainer.style.display = 'block';
                console.log(`Showing tensor values for match ${matchIndex}`);
                
                // Initialize slider ranges based on tensor size when first shown
                await initializeSliderRanges(matchIndex);
                await updateTensorValues(matchIndex);
            } else {
                valuesContainer.style.display = 'none';
                console.log(`Hiding tensor values for match ${matchIndex}`);
            }
        }
        
        async function initializeSliderRanges(matchIndex) {
            console.log(`initializeSliderRanges called for matchIndex: ${matchIndex}`);
            console.log(`globalMatches[${matchIndex}]:`, globalMatches[matchIndex]);
            
            // Get the ACTUAL tensor shape after TP-aware reshaping from the backend
            if (globalMatches[matchIndex]) {
                const match = globalMatches[matchIndex];
                // Make a quick request to get the final tensor info after any reshaping
                try {
                    const response = await fetch('/get_tensor_values', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            match_index: matchIndex,
                            dimension_indices: [],
                            count: 1,
                            get_final_shape: true  // Request final shape after reshaping
                        }),
                    });
                    const result = await response.json();
                    
                    if (!result.error && result.tensor_shape) {
                        // Use the final tensor shape from backend (after TP-aware reshaping)
                        console.log(`Creating sliders for final shape: [${result.tensor_shape.join(', ')}]`);
                        createDimensionSliders(matchIndex, result.tensor_shape, result.original_shapes);
                    } else {
                        // Fallback for scalar or error cases
                        createDimensionSliders(matchIndex, result.tensor_shape || [], null);
                    }
                } catch (error) {
                    console.log('Could not initialize slider range:', error);
                    createDimensionSliders(matchIndex, [], null);
                }
            }
        }
        
        function createDimensionSliders(matchIndex, tensorShape, originalShapes) {
            const dimensionContainer = document.getElementById(`dimension-controls-${matchIndex}`);
            
            if (tensorShape.length === 0) {
                // Scalar tensor - no dimension sliders needed
                dimensionContainer.innerHTML = '<p><em>Scalar value - no dimensions to slice</em></p>';
                return;
            }
            
            if (tensorShape.length === 1) {
                // 1D tensor - single dimension slider
                dimensionContainer.innerHTML = `
                    <div class="slider-group">
                        <label for="dim0-slider-${matchIndex}">Index (Dimension 0): <span id="dim0-value-${matchIndex}">0</span></label>
                        <input type="range" id="dim0-slider-${matchIndex}" min="0" max="${tensorShape[0] - 1}" value="0" 
                               oninput="updateDimensionSlider(${matchIndex}, 0)" 
                               onchange="updateTensorValues(${matchIndex})">
                    </div>
                `;
                return;
            }
            
            // Multi-dimensional tensor - create sliders for the FINAL tensor shape
            let slidersHTML = '<p><strong>Dimension Sliders (Final Shape):</strong></p>';
            
            // Show original shapes if available
            if (originalShapes && originalShapes.shape1 && originalShapes.shape2) {
                try {
                    slidersHTML += `<p><em>Original shapes: [${originalShapes.shape1.join(', ')}] vs [${originalShapes.shape2.join(', ')}] → Final: [${tensorShape.join(', ')}]</em></p>`;
                } catch (e) {
                    console.warn('Error displaying original shapes:', e);
                    slidersHTML += `<p><em>Final shape: [${tensorShape.join(', ')}]</em></p>`;
                }
            } else {
                slidersHTML += `<p><em>Final shape: [${tensorShape.join(', ')}]</em></p>`;
            }
            
            // Create sliders for each dimension of the final tensor shape
            for (let i = 0; i < tensorShape.length; i++) {
                const dimSize = tensorShape[i];
                slidersHTML += `
                    <div class="slider-group">
                        <label for="dim${i}-slider-${matchIndex}">Dim ${i} (size ${dimSize}): <span id="dim${i}-value-${matchIndex}">0</span></label>
                        <input type="range" id="dim${i}-slider-${matchIndex}" min="0" max="${dimSize - 1}" value="0" 
                               oninput="updateDimensionSlider(${matchIndex}, ${i})" 
                               onchange="updateTensorValues(${matchIndex})">
                    </div>
                `;
            }
            
            dimensionContainer.innerHTML = slidersHTML;
        }
        
        function updateDimensionSlider(matchIndex, dimensionIndex) {
            const slider = document.getElementById(`dim${dimensionIndex}-slider-${matchIndex}`);
            const valueSpan = document.getElementById(`dim${dimensionIndex}-value-${matchIndex}`);
            
            if (slider && valueSpan) {
                if (valueSpan) valueSpan.textContent = slider.value;
            }
        }
        
        function getDimensionIndices(matchIndex) {
            const indices = [];
            const dimensionContainer = document.getElementById(`dimension-controls-${matchIndex}`);
            
            console.log('getDimensionIndices - dimensionContainer found:', !!dimensionContainer);
            
            if (!dimensionContainer) {
                console.error(`Could not find dimension-controls-${matchIndex} element`);
                return [];
            }
            
            const sliders = dimensionContainer.querySelectorAll('input[type="range"]');
            console.log('getDimensionIndices - found sliders:', sliders.length);
            
            // Simply get the slider values in order - they now correspond directly to final tensor dimensions
            sliders.forEach((slider, index) => {
                const value = parseInt(slider.value) || 0;
                indices.push(value);
            });
            
            return indices;
        }
        
        function resetDimensionSliders(matchIndex) {
            const dimensionContainer = document.getElementById(`dimension-controls-${matchIndex}`);
            const sliders = dimensionContainer.querySelectorAll('input[type="range"]');
            
            sliders.forEach((slider, index) => {
                slider.value = 0;
                updateDimensionSlider(matchIndex, index);
            });
            
            updateTensorValues(matchIndex);
        }
        
        function updateSliderValue(matchIndex, type) {
            if (type === 'count') {
                const slider = document.getElementById(`count-slider-${matchIndex}`);
                const valueSpan = document.getElementById(`count-value-${matchIndex}`);
                const input = document.getElementById(`count-input-${matchIndex}`);
                if (valueSpan) valueSpan.textContent = slider.value;
                input.value = slider.value;
            }
        }
        
        function syncSliderFromInput(matchIndex, type) {
            if (type === 'count') {
                const input = document.getElementById(`count-input-${matchIndex}`);
                const slider = document.getElementById(`count-slider-${matchIndex}`);
                const valueSpan = document.getElementById(`count-value-${matchIndex}`);
                const value = Math.max(1, Math.min(100, parseInt(input.value) || 10));
                slider.value = value;
                valueSpan.textContent = value;
                input.value = value;
                updateTensorValues(matchIndex);
            }
        }
        
        async function updateTensorValues(matchIndex) {
            console.log('updateTensorValues called with matchIndex:', matchIndex);
            
            const countSlider = document.getElementById(`count-slider-${matchIndex}`);
            const displayDiv = document.getElementById(`tensor-display-${matchIndex}`);
            
            console.log('countSlider found:', !!countSlider);
            console.log('displayDiv found:', !!displayDiv);
            
            if (!displayDiv) {
                console.error(`Could not find tensor-display-${matchIndex} element`);
                return;
            }
            
            const dimensionIndices = getDimensionIndices(matchIndex);
            const count = parseInt(countSlider.value) || 10;
            
            console.log('dimensionIndices:', dimensionIndices);
            console.log('count:', count);
            
            displayDiv.innerHTML = '<div class="loading">Loading tensor values...</div>';
            
            try {
                const response = await fetch('/get_tensor_values', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        match_index: matchIndex,
                        dimension_indices: dimensionIndices,
                        count: count
                    }),
                });
                
                const result = await response.json();
                
                if (result.error) {
                    displayDiv.innerHTML = `<div class="error">Error: ${result.error}</div>`;
                    return;
                }
                
                // Initialize variables needed for display
                const indexOffset = 0; // For tooltip indexing
                
                // Helper function to format tensor values for display
                const formatTensorValue = (val) => {
                    if (typeof val === 'string') {
                        return val; // Return nan/inf strings as-is
                    }
                    if (typeof val === 'number') {
                        return val.toFixed(6);
                    }
                    return String(val);
                };

                // Helper function to get numeric value for calculations
                const getNumericValue = (val) => {
                    if (typeof val === 'string') {
                        if (val === 'nan') return NaN;
                        if (val === 'inf') return Infinity;
                        if (val === '-inf') return -Infinity;
                        return parseFloat(val) || 0;
                    }
                    return val;
                };

                // Helper function to calculate difference between two values
                const calculateDifference = (val1, val2) => {
                    const num1 = getNumericValue(val1);
                    const num2 = getNumericValue(val2);
                    
                    // Handle special cases
                    if (isNaN(num1) || isNaN(num2)) return NaN;
                    if (!isFinite(num1) || !isFinite(num2)) return Infinity;
                    
                    return Math.abs(num1 - num2);
                };

                // Define color functions for all cases
                const getBackgroundColor = (value, allValues = null) => {
                    const numValue = getNumericValue(value);
                    
                    // Special handling for nan/inf values
                    if (isNaN(numValue)) {
                        return '#ffcccc'; // Light red for NaN
                    }
                    if (!isFinite(numValue)) {
                        return '#ffffcc'; // Light yellow for inf/-inf
                    }
                    
                    const absValue = Math.abs(numValue);
                    
                    // Calculate intensity based on magnitude if we have all values for context
                    let intensity = 0.5; // Default medium intensity
                    if (allValues && allValues.length > 0) {
                        const numericValues = allValues.map(v => getNumericValue(v)).filter(v => isFinite(v) && !isNaN(v));
                        if (numericValues.length > 0) {
                            const maxAbs = Math.max(...numericValues.map(v => Math.abs(v)));
                            const minAbs = Math.min(...numericValues.map(v => Math.abs(v)));
                            if (maxAbs > minAbs) {
                                intensity = (absValue - minAbs) / (maxAbs - minAbs);
                            }
                        }
                    }
                    
                    if (numValue < 0) {
                        // Blue gradient: light blue to medium blue based on magnitude
                        const red = Math.floor(173 - (173 - 100) * intensity);   // 173 (light blue) to 100 (medium blue)
                        const green = Math.floor(216 - (216 - 149) * intensity); // 216 (light blue) to 149 (medium blue)  
                        const blue = Math.floor(230 - (230 - 237) * intensity);  // 230 (light blue) to 237 (medium blue)
                        return `rgb(${red}, ${green}, ${blue})`;
                    } else {
                        // Orange gradient: light orange to dark orange based on magnitude
                        const red = Math.floor(255 - (255 - 255) * intensity);   // 255 (light orange) to 255 (dark orange)
                        const green = Math.floor(228 - (228 - 140) * intensity); // 228 (light orange) to 140 (dark orange)
                        const blue = Math.floor(181 - (181 - 0) * intensity);    // 181 (light orange) to 0 (dark orange)
                        return `rgb(${red}, ${green}, ${blue})`;
                    }
                };
                
                const getBorderColor = (diff, maxDiffValue) => {
                    if (!maxDiffValue || maxDiffValue === 0) return '#90EE90'; // Light green if no difference
                    const normalizationFactor = 0.5; // 0.5 difference = dark color
                    const intensity = Math.min(diff / normalizationFactor, 1.0); // Cap at 1.0
                    
                    // Green to orange gradient for borders
                    const red = Math.floor(144 + (255 - 144) * intensity);   // 144 (light green) to 255 (orange)
                    const green = Math.floor(238 - (84 * intensity));        // 238 (light green) to 154 (orange)
                    const blue = Math.floor(144 - (144 * intensity));        // 144 (light green) to 0 (orange)
                    
                    return `rgb(${red}, ${green}, ${blue})`;
                };
                
                // Handle single model displays
                let tensorComparisonContent = '';
                
                if (result.tensor1_values && result.tensor2_values) {
                    // Both models have data - calculate differences and color code
                    const differences = result.tensor1_values.map((val1, idx) => 
                        calculateDifference(val1, result.tensor2_values[idx])
                    );
                    const validDiffs = differences.filter(d => isFinite(d) && !isNaN(d));
                    const maxDiff = validDiffs.length > 0 ? Math.max(...validDiffs) : 0;
                    const normalizationFactor = 0.5; // 0.5 difference = dark color
                    
                    // Store max difference for this tensor globally
                    if (!window.globalMaxDifferences) {
                        window.globalMaxDifferences = [];
                    }
                    window.globalMaxDifferences[matchIndex] = {
                        maxDiff: maxDiff,
                        layer: globalMatches[matchIndex]?.layer_num,
                        stage: globalMatches[matchIndex]?.stage_display,
                        matchIndex: matchIndex
                    };
                    
                    tensorComparisonContent = `
                        <div class="tensor-comparison">
                            <div class="tensor-column">
                                <h4>Model 1 Values</h4>
                                <div class="values-grid">
                                    ${result.tensor1_values.map((val, idx) => {
                                        const diff = differences[idx];
                                        const bgColor = getBackgroundColor(val, result.tensor1_values);
                                        const borderColor = getBorderColor(diff, maxDiff);
                                        const formattedVal = formatTensorValue(val);
                                        const formattedDiff = isFinite(diff) && !isNaN(diff) ? diff.toFixed(6) : String(diff);
                                        return `<div class="value-cell" 
                                                style="background-color: ${bgColor}; border: 2px solid ${borderColor};" 
                                                title="Index: ${indexOffset + idx}, Value: ${formattedVal}, Diff: ${formattedDiff}">${formattedVal}</div>`;
                                    }).join('')}
                                </div>
                            </div>
                            <div class="tensor-column">
                                <h4>Model 2 Values</h4>
                                <div class="values-grid">
                                    ${result.tensor2_values.map((val, idx) => {
                                        const diff = differences[idx];
                                        const bgColor = getBackgroundColor(val, result.tensor2_values);
                                        const borderColor = getBorderColor(diff, maxDiff);
                                        const formattedVal = formatTensorValue(val);
                                        const formattedDiff = isFinite(diff) && !isNaN(diff) ? diff.toFixed(6) : String(diff);
                                        return `<div class="value-cell" 
                                                style="background-color: ${bgColor}; border: 2px solid ${borderColor};" 
                                                title="Index: ${indexOffset + idx}, Value: ${formattedVal}, Diff: ${formattedDiff}">${formattedVal}</div>`;
                                    }).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                } else if (result.tensor1_values) {
                    // Only Model 1 has data
                    tensorComparisonContent = `
                        <div class="tensor-comparison single-model">
                            <div class="tensor-column">
                                <h4>Model 1 Values</h4>
                                <div class="values-grid">
                                    ${result.tensor1_values.map((val, idx) => {
                                        const bgColor = getBackgroundColor(val, result.tensor1_values);
                                        const formattedVal = formatTensorValue(val);
                                        return `<div class="value-cell" 
                                                style="background-color: ${bgColor}; border: 2px solid #90EE90;" 
                                                title="Index: ${indexOffset + idx}, Value: ${formattedVal}">${formattedVal}</div>`;
                                    }).join('')}
                                </div>
                            </div>
                            <div class="tensor-column missing-column">
                                <h4>Model 2 Values</h4>
                                <div class="missing-notice">Not available in Model 2</div>
                            </div>
                        </div>
                    `;
                } else if (result.tensor2_values) {
                    // Only Model 2 has data
                    tensorComparisonContent = `
                        <div class="tensor-comparison single-model">
                            <div class="tensor-column missing-column">
                                <h4>Model 1 Values</h4>
                                <div class="missing-notice">Not available in Model 1</div>
                            </div>
                            <div class="tensor-column">
                                <h4>Model 2 Values</h4>
                                <div class="values-grid">
                                    ${result.tensor2_values.map((val, idx) => {
                                        const bgColor = getBackgroundColor(val, result.tensor2_values);
                                        const formattedVal = formatTensorValue(val);
                                        return `<div class="value-cell" 
                                                style="background-color: ${bgColor}; border: 2px solid #90EE90;" 
                                                title="Index: ${indexOffset + idx}, Value: ${formattedVal}">${formattedVal}</div>`;
                                    }).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                const valueCount = result.tensor1_values ? result.tensor1_values.length : result.tensor2_values.length;
                const dimensionInfo = dimensionIndices.length > 0 ? `at indices [${dimensionIndices.join(', ')}]` : 'flattened view';
                
                displayDiv.innerHTML = `
                    ${tensorComparisonContent}
                    <div class="tensor-info-display">
                        <p><strong>Shape:</strong> [${result.tensor_shape.join(', ')}]</p>
                        <p><strong>Display Type:</strong> ${result.display_type}</p>
                        <p><strong>Viewing:</strong> ${valueCount} values ${dimensionInfo}</p>
                        ${result.slice_info ? `<p><strong>Slice Details:</strong> ${result.slice_info}</p>` : ''}
                    </div>
                `;
                
            } catch (error) {
                displayDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
            }
        }
        
        async function jumpToMaxDiffInTensor(matchIndex) {
            // First, expand the tensor values container if it's not already visible
            const valuesContainer = document.getElementById(`values-${matchIndex}`);
            if (valuesContainer && valuesContainer.style.display === 'none') {
                await showTensorValues(matchIndex);
            }
            
            // Make a request to get the argmax coordinates
            try {
                const response = await fetch('/get_tensor_values', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        match_index: matchIndex,
                        dimension_indices: [],
                        count: 1,
                        get_argmax: true  // Request argmax coordinates
                    }),
                });
                
                const result = await response.json();
                
                if (result.error) {
                    alert(`Error: ${result.error}`);
                    return;
                }
                
                if (!result.argmax_coordinates || result.argmax_coordinates.length === 0) {
                    // No argmax available for this tensor (might be single-model or scalar)
                    alert('No maximum difference location available for this tensor.');
                    return;
                }
                
                const argmaxCoords = result.argmax_coordinates;
                
                // Update dimension sliders to show the argmax position
                const dimensionContainer = document.getElementById(`dimension-controls-${matchIndex}`);
                const sliders = dimensionContainer.querySelectorAll('input[type="range"]');
                
                // Set each dimension slider to the argmax coordinate
                sliders.forEach((slider, dimIndex) => {
                    if (dimIndex < argmaxCoords.length) {
                        slider.value = argmaxCoords[dimIndex];
                        updateDimensionSlider(matchIndex, dimIndex);
                    }
                });
                
                // Update tensor values with the new position
                await updateTensorValues(matchIndex);
                
                // Scroll to the display and highlight it
                const displayDiv = document.getElementById(`tensor-display-${matchIndex}`);
                if (displayDiv) {
                    displayDiv.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'start' 
                    });
                    
                    // Highlight the tensor display
                    displayDiv.style.border = '3px solid #ff4444';
                    setTimeout(() => {
                        displayDiv.style.border = '';
                    }, 3000);
                    
                    // Show success message
                    const coords = argmaxCoords.join(', ');
                    const tempMessage = document.createElement('div');
                    tempMessage.innerHTML = `<div style="background: #28a745; color: white; padding: 10px; border-radius: 5px; margin: 10px 0; text-align: center;">🎯 Jumped to max difference at coordinates [${coords}]</div>`;
                    displayDiv.insertBefore(tempMessage, displayDiv.firstChild);
                    
                    setTimeout(() => {
                        tempMessage.remove();
                    }, 3000);
                }
                
            } catch (error) {
                alert(`Error finding max difference: ${error.message}`);
            }
        }
        
        function collapseAll() {
            const matchItems = document.querySelectorAll('.match-item');
            matchItems.forEach(item => {
                item.classList.add('collapsed');
            });
        }
        
        function expandAll() {
            const matchItems = document.querySelectorAll('.match-item');
            matchItems.forEach(item => {
                item.classList.remove('collapsed');
            });
        }
        
        function toggleMatch(matchIndex) {
            console.log(`toggleMatch called for matchIndex: ${matchIndex}`);
            const matchItem = document.querySelector(`[data-match-index="${matchIndex}"]`);
            console.log(`Found matchItem:`, matchItem);
            
            if (matchItem) {
                const wasCollapsed = matchItem.classList.contains('collapsed');
                matchItem.classList.toggle('collapsed');
                console.log(`Toggled from ${wasCollapsed ? 'collapsed' : 'expanded'} to ${matchItem.classList.contains('collapsed') ? 'collapsed' : 'expanded'}`);
            } else {
                console.error(`Could not find match item with index ${matchIndex}`);
            }
        }
        
        // Manual dimension mapping functions
        let mappingMode = {}; // Track mapping mode per match
        let originalShapes = {}; // Store original shapes per match
        
        function toggleMappingMode(matchIndex) {
            const mappingDiv = document.getElementById(`dimension-mapping-${matchIndex}`);
            const autoDiv = document.getElementById(`auto-controls-${matchIndex}`);
            
            if (!mappingMode[matchIndex]) {
                // Switch to manual mapping mode
                mappingDiv.style.display = 'block';
                autoDiv.style.display = 'none';
                mappingMode[matchIndex] = true;
                initializeDimensionMapping(matchIndex);
            } else {
                // Switch to auto mode
                mappingDiv.style.display = 'none';
                autoDiv.style.display = 'block';
                mappingMode[matchIndex] = false;
            }
        }
        
        async function initializeDimensionMapping(matchIndex) {
            const mappingContainer = document.getElementById(`mapping-controls-${matchIndex}`);
            
            try {
                // Get original tensor shapes before any reshaping
                const response = await fetch('/get_tensor_shapes', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        match_index: matchIndex
                    }),
                });
                const result = await response.json();
                
                if (result.error) {
                    mappingContainer.innerHTML = `<p>Error: ${result.error}</p>`;
                    return;
                }
                
                // Store for later use
                originalShapes[matchIndex] = result;
                
                let mappingHTML = '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">';
                
                // Tensor 1 controls
                if (result.tensor1_shape) {
                    mappingHTML += `
                        <div>
                            <h5>Tensor 1 (${result.tensor1_name || 'Model 1'})</h5>
                            <p><em>Original shape: [${result.tensor1_shape.join(', ')}]</em></p>
                            ${createTensorMappingControls(matchIndex, 1, result.tensor1_shape)}
                        </div>
                    `;
                }
                
                // Tensor 2 controls
                if (result.tensor2_shape) {
                    mappingHTML += `
                        <div>
                            <h5>Tensor 2 (${result.tensor2_name || 'Model 2'})</h5>
                            <p><em>Original shape: [${result.tensor2_shape.join(', ')}]</em></p>
                            ${createTensorMappingControls(matchIndex, 2, result.tensor2_shape)}
                        </div>
                    `;
                }
                
                mappingHTML += '</div>';
                
                // Add values to show control and convenience buttons
                mappingHTML += `
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <label for="manual-count-slider-${matchIndex}" style="font-weight: bold;">
                                    Values to Show: <span id="manual-count-value-${matchIndex}">10</span>
                                </label>
                                <input type="range" 
                                       id="manual-count-slider-${matchIndex}" 
                                       min="1" 
                                       max="100" 
                                       value="10" 
                                       style="width: 120px;"
                                       oninput="updateManualCountSlider(${matchIndex})"
                                       onchange="updateManualCountSlider(${matchIndex})">
                                <input type="number" 
                                       id="manual-count-input-${matchIndex}" 
                                       value="10" 
                                       min="1" 
                                       max="100" 
                                       style="width: 50px;"
                                       onchange="syncManualCountFromInput(${matchIndex})">
                            </div>
                            <div>
                                <label>
                                    <input type="checkbox" id="auto-update-${matchIndex}" checked onchange="toggleAutoUpdate(${matchIndex})"> 
                                    Auto-update on slider change
                                </label>
                            </div>
                        </div>
                        <div style="margin-top: 10px;">
                            <button onclick="resetManualSliders(${matchIndex})" style="background-color: #6c757d; margin-right: 10px;">Reset All to 0</button>
                            <button onclick="copyTensor1ToTensor2(${matchIndex})" style="background-color: #17a2b8; margin-right: 10px;">Copy T1→T2 Settings</button>
                            ${result.tensor1_shape && result.tensor2_shape ? `<button onclick="tryCommonMappings(${matchIndex})" style="background-color: #ffc107; color: black;">Try Common Mappings</button>` : ''}
                        </div>
                    </div>
                `;
                
                mappingContainer.innerHTML = mappingHTML;
                
            } catch (error) {
                console.error('Error initializing dimension mapping:', error);
                mappingContainer.innerHTML = `<p>Error loading tensor shapes: ${error.message}</p>`;
            }
        }
        
        function createTensorMappingControls(matchIndex, tensorNum, shape) {
            let html = '';
            
            for (let i = 0; i < shape.length; i++) {
                html += `
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; font-weight: bold; margin-bottom: 4px;">
                            Dim ${i} (size ${shape[i]}): <span id="t${tensorNum}-dim${i}-value-${matchIndex}">0</span>
                        </label>
                        <input type="range" 
                               id="t${tensorNum}-dim${i}-slider-${matchIndex}" 
                               min="0" 
                               max="${shape[i] - 1}" 
                               value="0" 
                               style="width: 200px; margin-right: 10px;"
                               oninput="updateManualSlider(${matchIndex}, ${tensorNum}, ${i})"
                               onchange="updateManualSlider(${matchIndex}, ${tensorNum}, ${i})">
                        <input type="number" 
                               id="t${tensorNum}-dim${i}-input-${matchIndex}" 
                               value="0" 
                               min="0" 
                               max="${shape[i] - 1}" 
                               style="width: 50px; margin-left: 5px;"
                               onchange="syncManualSliderFromInput(${matchIndex}, ${tensorNum}, ${i})">
                        <span style="font-size: 12px; color: #666; margin-left: 5px;">(0-${shape[i] - 1})</span>
                    </div>
                `;
            }
            
            return html;
        }
        
        function updateManualSlider(matchIndex, tensorNum, dimIndex) {
            const slider = document.getElementById(`t${tensorNum}-dim${dimIndex}-slider-${matchIndex}`);
            const valueSpan = document.getElementById(`t${tensorNum}-dim${dimIndex}-value-${matchIndex}`);
            const input = document.getElementById(`t${tensorNum}-dim${dimIndex}-input-${matchIndex}`);
            
            if (slider && valueSpan && input) {
                const value = slider.value;
                valueSpan.textContent = value;
                input.value = value;
                
                // Auto-update if enabled
                const autoUpdateCheckbox = document.getElementById(`auto-update-${matchIndex}`);
                if (autoUpdateCheckbox && autoUpdateCheckbox.checked) {
                    // Debounce the auto-update to avoid too many requests
                    clearTimeout(window[`autoUpdateTimer_${matchIndex}`]);
                    window[`autoUpdateTimer_${matchIndex}`] = setTimeout(() => {
                        applyDimensionMapping(matchIndex);
                    }, 500); // 500ms delay
                }
            }
        }
        
        function syncManualSliderFromInput(matchIndex, tensorNum, dimIndex) {
            const slider = document.getElementById(`t${tensorNum}-dim${dimIndex}-slider-${matchIndex}`);
            const valueSpan = document.getElementById(`t${tensorNum}-dim${dimIndex}-value-${matchIndex}`);
            const input = document.getElementById(`t${tensorNum}-dim${dimIndex}-input-${matchIndex}`);
            
            if (slider && valueSpan && input) {
                let value = parseInt(input.value) || 0;
                const max = parseInt(slider.max);
                const min = parseInt(slider.min);
                
                // Clamp value to slider range
                value = Math.max(min, Math.min(max, value));
                
                slider.value = value;
                valueSpan.textContent = value;
                input.value = value; // Update input in case it was clamped
            }
        }
        
        async function applyDimensionMapping(matchIndex) {
            const shapes = originalShapes[matchIndex];
            if (!shapes) {
                alert('Tensor shapes not loaded. Please try again.');
                return;
            }
            
            // Collect dimension indices for both tensors
            const tensor1_indices = [];
            const tensor2_indices = [];
            
            if (shapes.tensor1_shape) {
                for (let i = 0; i < shapes.tensor1_shape.length; i++) {
                    const slider = document.getElementById(`t1-dim${i}-slider-${matchIndex}`);
                    if (slider) {
                        tensor1_indices.push(parseInt(slider.value) || 0);
                    }
                }
            }
            
            if (shapes.tensor2_shape) {
                for (let i = 0; i < shapes.tensor2_shape.length; i++) {
                    const slider = document.getElementById(`t2-dim${i}-slider-${matchIndex}`);
                    if (slider) {
                        tensor2_indices.push(parseInt(slider.value) || 0);
                    }
                }
            }
            
            const count = parseInt(document.getElementById(`manual-count-input-${matchIndex}`).value) || 10;
            
            try {
                const response = await fetch('/get_tensor_values_manual', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        match_index: matchIndex,
                        tensor1_indices: tensor1_indices,
                        tensor2_indices: tensor2_indices,
                        count: count
                    }),
                });
                
                const result = await response.json();
                
                if (result.error) {
                    alert(`Error: ${result.error}`);
                    return;
                }
                
                displayManualTensorValues(matchIndex, result);
                
            } catch (error) {
                console.error('Error applying dimension mapping:', error);
                alert(`Error: ${error.message}`);
            }
        }
        
        function displayManualTensorValues(matchIndex, result) {
            // Helper function to get numeric value for calculations
            const getNumericValue = (val) => {
                if (typeof val === 'string') {
                    if (val === 'nan') return NaN;
                    if (val === 'inf') return Infinity;
                    if (val === '-inf') return -Infinity;
                    return parseFloat(val) || 0;
                }
                return val;
            };

            const displayDiv = document.getElementById(`tensor-display-${matchIndex}`);
            
            let html = '<div class="tensor-comparison">';
            
            // Add summary statistics if available
            if (result.summary_stats && !result.summary_stats.error) {
                const stats = result.summary_stats;
                const isIdentical = stats.comparison_info.values_identical;
                const maxDiff = stats.difference_stats.abs_diff_max;
                const cosineSim = stats.difference_stats.cosine_sim;
                
                html += `<div class="summary-stats" style="margin-bottom: 15px; ${isIdentical ? 'background-color: #e8f5e8; border-color: #28a745;' : ''}">`;
                html += '<h5>Manual Mapping Statistics</h5>';
                html += '<div class="stats-grid">';
                
                // Tensor 1 stats
                html += `<div class="stat-item">`;
                html += `<span class="stat-label">Model 1 Mean:</span>`;
                html += `<span class="stat-value">${stats.tensor1_stats.mean.toFixed(6)}</span>`;
                html += `</div>`;
                html += `<div class="stat-item">`;
                html += `<span class="stat-label">Model 2 Mean:</span>`;
                html += `<span class="stat-value">${stats.tensor2_stats.mean.toFixed(6)}</span>`;
                html += `</div>`;
                
                // Difference stats (highlighted)
                html += `<div class="stat-item highlight">`;
                html += `<span class="stat-label">Max Difference:</span>`;
                html += `<span class="stat-value">${maxDiff.toFixed(6)}</span>`;
                html += `</div>`;
                html += `<div class="stat-item highlight">`;
                html += `<span class="stat-label">Cosine Similarity:</span>`;
                html += `<span class="stat-value">${cosineSim.toFixed(6)}</span>`;
                html += `</div>`;
                
                // Comparison info
                html += `<div class="stat-item">`;
                html += `<span class="stat-label">Elements Compared:</span>`;
                html += `<span class="stat-value">${stats.comparison_info.elements_compared}</span>`;
                html += `</div>`;
                html += `<div class="stat-item ${isIdentical ? 'highlight' : ''}">`;
                html += `<span class="stat-label">Values Identical:</span>`;
                html += `<span class="stat-value">${isIdentical ? '✓ YES' : '✗ NO'}</span>`;
                html += `</div>`;
                
                html += '</div>';
                
                // Add interpretation note
                if (isIdentical) {
                    html += '<div style="text-align: center; margin-top: 10px; padding: 8px; background-color: #d4edda; border-radius: 4px; color: #155724;">';
                    html += '🎉 <strong>Values are identical!</strong> This mapping reveals the tensors contain the same data.';
                    html += '</div>';
                } else if (cosineSim > 0.999 && maxDiff < 1e-3) {
                    html += '<div style="text-align: center; margin-top: 10px; padding: 8px; background-color: #d4edda; border-radius: 4px; color: #155724;">';
                    html += '✅ <strong>Values are very similar!</strong> This mapping reveals nearly identical tensor data.';
                    html += '</div>';
                } else if (cosineSim > 0.99 && maxDiff < 0.1) {
                    html += '<div style="text-align: center; margin-top: 10px; padding: 8px; background-color: #d4edda; border-radius: 4px; color: #155724;">';
                    html += '✅ <strong>Good alignment found!</strong> This mapping shows high similarity between tensors.';
                    html += '</div>';
                } else if (cosineSim > 0.5) {
                    html += '<div style="text-align: center; margin-top: 10px; padding: 8px; background-color: #fff3cd; border-radius: 4px; color: #856404;">';
                    html += '⚠️ Moderate similarity. Try adjusting dimension mappings for better alignment.';
                    html += '</div>';
                } else {
                    html += '<div style="text-align: center; margin-top: 10px; padding: 8px; background-color: #f8d7da; border-radius: 4px; color: #721c24;">';
                    html += '❌ Low similarity. Try different dimension mappings to explore other alignments.';
                    html += '</div>';
                }
                
                html += '</div>';
            } else if (result.summary_stats && result.summary_stats.error) {
                html += `<div class="summary-stats error" style="margin-bottom: 15px;">`;
                html += `<strong>Statistics Error:</strong> ${result.summary_stats.error}`;
                html += `</div>`;
            }
            
            html += '<div class="comparison-info">';
            html += `<p><strong>Manual Mapping Applied</strong></p>`;
            html += `<p>Tensor 1 slice: [${result.tensor1_slice_info || 'N/A'}]</p>`;
            html += `<p>Tensor 2 slice: [${result.tensor2_slice_info || 'N/A'}]</p>`;
            html += '</div>';
            
            // Create table showing values side by side
            if (result.tensor1_values || result.tensor2_values) {
                html += '<div class="values-table">';
                html += '<table style="width: 100%; border-collapse: collapse; margin-top: 10px;">';
                html += '<thead><tr><th style="border: 1px solid #ccc; padding: 8px;">Index</th>';
                
                if (result.tensor1_values) {
                    html += '<th style="border: 1px solid #ccc; padding: 8px; background-color: #e3f2fd;">Tensor 1</th>';
                }
                if (result.tensor2_values) {
                    html += '<th style="border: 1px solid #ccc; padding: 8px; background-color: #fff3e0;">Tensor 2</th>';
                }
                if (result.tensor1_values && result.tensor2_values) {
                    html += '<th style="border: 1px solid #ccc; padding: 8px; background-color: #f3e5f5;">Difference</th>';
                }
                
                html += '</tr></thead><tbody>';
                
                const maxLength = Math.max(
                    result.tensor1_values ? result.tensor1_values.length : 0,
                    result.tensor2_values ? result.tensor2_values.length : 0
                );
                
                for (let i = 0; i < maxLength; i++) {
                    html += '<tr>';
                    html += `<td style="border: 1px solid #ccc; padding: 8px; font-weight: bold;">${i}</td>`;
                    
                    const val1 = result.tensor1_values && i < result.tensor1_values.length ? result.tensor1_values[i] : null;
                    const val2 = result.tensor2_values && i < result.tensor2_values.length ? result.tensor2_values[i] : null;
                    
                    if (result.tensor1_values) {
                        const formatted1 = val1 !== null ? (typeof val1 === 'number' ? val1.toFixed(6) : val1) : 'N/A';
                        html += `<td style="border: 1px solid #ccc; padding: 8px; background-color: #e3f2fd;">${formatted1}</td>`;
                    }
                    
                    if (result.tensor2_values) {
                        const formatted2 = val2 !== null ? (typeof val2 === 'number' ? val2.toFixed(6) : val2) : 'N/A';
                        html += `<td style="border: 1px solid #ccc; padding: 8px; background-color: #fff3e0;">${formatted2}</td>`;
                    }
                    
                    if (result.tensor1_values && result.tensor2_values && val1 !== null && val2 !== null) {
                        const num1 = getNumericValue(val1);
                        const num2 = getNumericValue(val2);
                        
                        let diffFormatted;
                        let diffColor;
                        
                        if (isNaN(num1) || isNaN(num2)) {
                            diffFormatted = 'N/A (NaN)';
                            diffColor = '#ffcccc';
                        } else if (!isFinite(num1) || !isFinite(num2)) {
                            diffFormatted = 'N/A (Inf)';
                            diffColor = '#ffffcc';
                        } else {
                            const diff = num1 - num2;
                            diffFormatted = Math.abs(diff) < 1e-10 ? '0.000000' : diff.toFixed(6);
                            diffColor = Math.abs(diff) > 1e-6 ? '#ffebee' : '#e8f5e8';
                        }
                        
                        html += `<td style="border: 1px solid #ccc; padding: 8px; background-color: ${diffColor};">${diffFormatted}</td>`;
                    }
                    
                    html += '</tr>';
                }
                
                html += '</tbody></table>';
                html += '</div>';
            }
            
            html += '</div>';
            displayDiv.innerHTML = html;
        }
        
        function toggleAutoUpdate(matchIndex) {
            const checkbox = document.getElementById(`auto-update-${matchIndex}`);
            console.log(`Auto-update for match ${matchIndex}: ${checkbox.checked ? 'enabled' : 'disabled'}`);
        }
        
        function resetManualSliders(matchIndex) {
            const shapes = originalShapes[matchIndex];
            if (!shapes) return;
            
            // Reset all tensor 1 sliders
            if (shapes.tensor1_shape) {
                for (let i = 0; i < shapes.tensor1_shape.length; i++) {
                    const slider = document.getElementById(`t1-dim${i}-slider-${matchIndex}`);
                    const input = document.getElementById(`t1-dim${i}-input-${matchIndex}`);
                    const valueSpan = document.getElementById(`t1-dim${i}-value-${matchIndex}`);
                    
                    if (slider) slider.value = 0;
                    if (input) input.value = 0;
                    if (valueSpan) valueSpan.textContent = '0';
                }
            }
            
            // Reset all tensor 2 sliders
            if (shapes.tensor2_shape) {
                for (let i = 0; i < shapes.tensor2_shape.length; i++) {
                    const slider = document.getElementById(`t2-dim${i}-slider-${matchIndex}`);
                    const input = document.getElementById(`t2-dim${i}-input-${matchIndex}`);
                    const valueSpan = document.getElementById(`t2-dim${i}-value-${matchIndex}`);
                    
                    if (slider) slider.value = 0;
                    if (input) input.value = 0;
                    if (valueSpan) valueSpan.textContent = '0';
                }
            }
            
            // Auto-apply if enabled
            const autoUpdateCheckbox = document.getElementById(`auto-update-${matchIndex}`);
            if (autoUpdateCheckbox && autoUpdateCheckbox.checked) {
                applyDimensionMapping(matchIndex);
            }
        }
        
        function copyTensor1ToTensor2(matchIndex) {
            const shapes = originalShapes[matchIndex];
            if (!shapes || !shapes.tensor1_shape || !shapes.tensor2_shape) return;
            
            // Copy values from tensor 1 sliders to tensor 2 sliders (up to the minimum length)
            const minDims = Math.min(shapes.tensor1_shape.length, shapes.tensor2_shape.length);
            
            for (let i = 0; i < minDims; i++) {
                const t1Slider = document.getElementById(`t1-dim${i}-slider-${matchIndex}`);
                const t2Slider = document.getElementById(`t2-dim${i}-slider-${matchIndex}`);
                const t2Input = document.getElementById(`t2-dim${i}-input-${matchIndex}`);
                const t2ValueSpan = document.getElementById(`t2-dim${i}-value-${matchIndex}`);
                
                if (t1Slider && t2Slider) {
                    // Clamp to target tensor's dimension size
                    const t1Value = parseInt(t1Slider.value);
                    const maxValue = parseInt(t2Slider.max);
                    const clampedValue = Math.min(t1Value, maxValue);
                    
                    t2Slider.value = clampedValue;
                    if (t2Input) t2Input.value = clampedValue;
                    if (t2ValueSpan) t2ValueSpan.textContent = clampedValue;
                }
            }
            
            // Auto-apply if enabled
            const autoUpdateCheckbox = document.getElementById(`auto-update-${matchIndex}`);
            if (autoUpdateCheckbox && autoUpdateCheckbox.checked) {
                applyDimensionMapping(matchIndex);
            }
        }
        
        function tryCommonMappings(matchIndex) {
            const shapes = originalShapes[matchIndex];
            if (!shapes || !shapes.tensor1_shape || !shapes.tensor2_shape) return;
            
            const t1Shape = shapes.tensor1_shape;
            const t2Shape = shapes.tensor2_shape;
            
            // Define some common mapping patterns to try
            const mappings = [
                {
                    name: "Identity mapping (0,0,0...)",
                    t1: new Array(t1Shape.length).fill(0),
                    t2: new Array(t2Shape.length).fill(0)
                }
            ];
            
            // Add pattern for removing leading 1 dimensions
            if (t2Shape[0] === 1 && t2Shape.length > t1Shape.length) {
                mappings.push({
                    name: "Skip leading 1 dim in T2",
                    t1: new Array(t1Shape.length).fill(0),
                    t2: [0, ...new Array(t1Shape.length).fill(0)]
                });
            }
            
            if (t1Shape[0] === 1 && t1Shape.length > t2Shape.length) {
                mappings.push({
                    name: "Skip leading 1 dim in T1", 
                    t1: [0, ...new Array(t2Shape.length).fill(0)],
                    t2: new Array(t2Shape.length).fill(0)
                });
            }
            
            // Show dialog with mapping options
            let message = "Choose a common mapping pattern:\\n\\n";
            message += `Tensor 1 shape: [${t1Shape.join(', ')}]\\n`;
            message += `Tensor 2 shape: [${t2Shape.join(', ')}]\\n\\n`;
            
            mappings.forEach((mapping, idx) => {
                message += `${idx + 1}. ${mapping.name}\\n`;
            });
            
            const choice = prompt(message + "\\nEnter number (1-" + mappings.length + "), or cancel:");
            const choiceNum = parseInt(choice);
            
            if (choiceNum >= 1 && choiceNum <= mappings.length) {
                const mapping = mappings[choiceNum - 1];
                
                // Apply the mapping
                applyMappingPattern(matchIndex, mapping.t1, mapping.t2);
                
                // Auto-apply if enabled
                const autoUpdateCheckbox = document.getElementById(`auto-update-${matchIndex}`);
                if (autoUpdateCheckbox && autoUpdateCheckbox.checked) {
                    applyDimensionMapping(matchIndex);
                }
            }
        }
        
        function applyMappingPattern(matchIndex, t1Values, t2Values) {
            // Set tensor 1 sliders
            t1Values.forEach((value, i) => {
                const slider = document.getElementById(`t1-dim${i}-slider-${matchIndex}`);
                const input = document.getElementById(`t1-dim${i}-input-${matchIndex}`);
                const valueSpan = document.getElementById(`t1-dim${i}-value-${matchIndex}`);
                
                if (slider) {
                    const clampedValue = Math.max(0, Math.min(value, parseInt(slider.max)));
                    slider.value = clampedValue;
                    if (input) input.value = clampedValue;
                    if (valueSpan) valueSpan.textContent = clampedValue;
                }
            });
            
            // Set tensor 2 sliders
            t2Values.forEach((value, i) => {
                const slider = document.getElementById(`t2-dim${i}-slider-${matchIndex}`);
                const input = document.getElementById(`t2-dim${i}-input-${matchIndex}`);
                const valueSpan = document.getElementById(`t2-dim${i}-value-${matchIndex}`);
                
                if (slider) {
                    const clampedValue = Math.max(0, Math.min(value, parseInt(slider.max)));
                    slider.value = clampedValue;
                    if (input) input.value = clampedValue;
                    if (valueSpan) valueSpan.textContent = clampedValue;
                }
            });
        }
        
        function updateManualCountSlider(matchIndex) {
            const slider = document.getElementById(`manual-count-slider-${matchIndex}`);
            const valueSpan = document.getElementById(`manual-count-value-${matchIndex}`);
            const input = document.getElementById(`manual-count-input-${matchIndex}`);
            
            if (slider && valueSpan && input) {
                const value = slider.value;
                valueSpan.textContent = value;
                input.value = value;
                
                // Auto-apply if enabled
                const autoUpdateCheckbox = document.getElementById(`auto-update-${matchIndex}`);
                if (autoUpdateCheckbox && autoUpdateCheckbox.checked) {
                    // Debounce the auto-update to avoid too many requests
                    clearTimeout(window[`autoUpdateCountTimer_${matchIndex}`]);
                    window[`autoUpdateCountTimer_${matchIndex}`] = setTimeout(() => {
                        applyDimensionMapping(matchIndex);
                    }, 500); // 500ms delay
                }
            }
        }
        
        function syncManualCountFromInput(matchIndex) {
            const slider = document.getElementById(`manual-count-slider-${matchIndex}`);
            const valueSpan = document.getElementById(`manual-count-value-${matchIndex}`);
            const input = document.getElementById(`manual-count-input-${matchIndex}`);
            
            if (slider && valueSpan && input) {
                let value = parseInt(input.value) || 10;
                const max = parseInt(slider.max);
                const min = parseInt(slider.min);
                
                // Clamp value to slider range
                value = Math.max(min, Math.min(max, value));
                
                slider.value = value;
                valueSpan.textContent = value;
                input.value = value; // Update input in case it was clamped
                
                // Auto-apply if enabled
                const autoUpdateCheckbox = document.getElementById(`auto-update-${matchIndex}`);
                if (autoUpdateCheckbox && autoUpdateCheckbox.checked) {
                    applyDimensionMapping(matchIndex);
                }
            }
        }
        
        async function quickManualMapping(matchIndex) {
            // Open tensor values if not already open
            const valuesContainer = document.getElementById(`values-${matchIndex}`);
            if (valuesContainer.style.display === 'none') {
                await showTensorValues(matchIndex);
            }
            
            // Switch directly to manual mapping mode
            const mappingDiv = document.getElementById(`dimension-mapping-${matchIndex}`);
            const autoDiv = document.getElementById(`auto-controls-${matchIndex}`);
            
            if (mappingDiv && autoDiv) {
                // Switch to manual mapping mode
                mappingDiv.style.display = 'block';
                autoDiv.style.display = 'none';
                mappingMode[matchIndex] = true;
                
                // Initialize dimension mapping if not already done
                if (!originalShapes[matchIndex]) {
                    await initializeDimensionMapping(matchIndex);
                }
                
                // Scroll to the manual mapping interface
                mappingDiv.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
                
                // Highlight the interface briefly
                mappingDiv.style.border = '2px solid #17a2b8';
                setTimeout(() => {
                    mappingDiv.style.border = '';
                }, 2000);
            }
        }
        
        
        function updateUploadButton() {
            const uploadBtn = document.getElementById('upload-btn');
            uploadBtn.disabled = !(file1 && file2 && detectedMode && detectedMode !== 'mixed');
            
            // Update button text and show mode info
            if (detectedMode === 'dual_archive') {
                if (uploadBtn) uploadBtn.textContent = 'Compare Model Archives';
            } else if (detectedMode === 'dual_pth') {
                if (uploadBtn) uploadBtn.textContent = 'Compare Tensor Files';
            } else if (detectedMode === 'mixed') {
                if (uploadBtn) uploadBtn.textContent = 'Incompatible File Types';
                uploadBtn.disabled = true;
            } else if (file1 || file2) {
                if (uploadBtn) uploadBtn.textContent = 'Upload Both Files';
            } else {
                if (uploadBtn) uploadBtn.textContent = 'Upload Files to Compare';
            }
        }
        
        async function uploadAndCompare() {
            showProgress();
            updateProgress(10);
            
            const formData = new FormData();
            
            if (detectedMode === 'dual_archive') {
                // Archive vs Archive comparison
                formData.append('model1', file1);
                formData.append('model2', file2);
            } else if (detectedMode === 'dual_pth') {
                // .pth vs .pth direct comparison (new feature!)
                formData.append('model1', file1);
                formData.append('model2', file2);
                formData.append('upload_mode', 'dual_pth');
            } else {
                alert('Please upload two compatible files: either 2 archives or 2 .pth files');
                hideProgress();
                return;
            }
            
            try {
                updateProgress(50);
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                
                updateProgress(80);
                const result = await response.json();
                
                if (result.error) {
                    throw new Error(result.error);
                }
                
                updateProgress(90);
                await displayResults(result);
                updateProgress(100);
                
                setTimeout(hideProgress, 500);
                
            } catch (error) {
                hideProgress();
                document.getElementById('results').innerHTML = 
                    `<div class="error">Error: ${error.message}</div>`;
                document.getElementById('results').style.display = 'block';
            }
        }
        
        // Initialize two-box upload system
        setupDropZone('file1-drop', 'file1', 'file1-info');
        setupDropZone('file2-drop', 'file2', 'file2-info');
        document.getElementById('upload-btn').addEventListener('click', uploadAndCompare);
        
        
        function updateDetectedMode() {
            if (file1 && file2) {
                const file1IsArchive = file1.name.match(/\.(zip|tar\.gz|tgz)$/i);
                const file2IsArchive = file2.name.match(/\.(zip|tar\.gz|tgz)$/i);
                const file1IsPth = file1.name.match(/\.(pth|pt)$/i);
                const file2IsPth = file2.name.match(/\.(pth|pt)$/i);
                const file1IsSafetensors = file1.name.match(/\.safetensors$/i);
                const file2IsSafetensors = file2.name.match(/\.safetensors$/i);
                
                // Check for tensor files (both .pth and .safetensors)
                const file1IsTensor = file1IsPth || file1IsSafetensors;
                const file2IsTensor = file2IsPth || file2IsSafetensors;
                
                if (file1IsArchive && file2IsArchive) {
                    detectedMode = 'dual_archive';
                } else if (file1IsTensor && file2IsTensor) {
                    detectedMode = 'dual_pth'; // Use same mode for all tensor files
                } else {
                    detectedMode = 'mixed'; // Different types - we'll handle this
                }
            } else {
                detectedMode = null;
            }
        }
    </script>
</body>
</html>