<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Model Tensor Debugger</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .drop-zone {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background-color: #fafafa;
        }
        
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #007bff;
            background-color: #f0f8ff;
        }
        
        .drop-zone.file-loaded {
            border-color: #28a745;
            background-color: #f0fff0;
        }
        
        .drop-zone input[type="file"] {
            display: none;
        }
        
        .drop-zone-text {
            font-size: 16px;
            color: #666;
            margin-bottom: 10px;
        }
        
        .file-info {
            font-size: 14px;
            color: #007bff;
            font-weight: bold;
        }
        
        .upload-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            display: block;
            margin: 20px auto;
            transition: background-color 0.3s;
        }
        
        .upload-btn:hover {
            background-color: #0056b3;
        }
        
        .upload-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .progress {
            display: none;
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #007bff;
            width: 0%;
            transition: width 0.3s;
        }
        
        .results {
            margin-top: 30px;
            display: none;
        }
        
        .summary {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .match-item {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .match-item.collapsed {
            padding: 10px 15px;
        }
        
        .match-item.collapsed .match-content {
            display: none;
        }
        
        .match-header {
            font-weight: bold;
            color: #495057;
            margin-bottom: 10px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-radius: 3px;
            transition: background-color 0.2s;
        }
        
        .match-header:hover {
            background-color: #e9ecef;
            padding: 5px 10px;
        }
        
        .collapse-indicator {
            font-size: 14px;
            color: #6c757d;
            transition: transform 0.2s;
        }
        
        .match-item.collapsed .collapse-indicator {
            transform: rotate(-90deg);
        }
        
        .match-summary {
            font-size: 12px;
            color: #6c757d;
            font-weight: normal;
            margin-left: 10px;
        }
        
        .tensor-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .tensor-details {
            background-color: white;
            padding: 10px;
            border-radius: 3px;
            border-left: 4px solid #007bff;
        }
        
        .diff-stats {
            background-color: #fff3cd;
            padding: 10px;
            border-radius: 3px;
            border-left: 4px solid #ffc107;
            margin-bottom: 15px;
        }
        
        .error {
            color: #dc3545;
            background-color: #f8d7da;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
        }
        
        .plot-container {
            margin-top: 15px;
            min-height: 400px;
        }
        
        .shape-mismatch {
            background-color: #f8d7da;
            border-left-color: #dc3545;
        }
        
        .layer-group {
            margin-bottom: 30px;
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 20px;
            background-color: #f8f9fa;
        }
        
        .layer-group h3 {
            color: #007bff;
            margin-top: 0;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        
        .inspect-btn {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 10px 0;
        }
        
        .inspect-btn:hover {
            background-color: #218838;
        }
        
        .values-container {
            background-color: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
        }
        
        .slice-controls {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        
        .slider-group {
            margin-bottom: 15px;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #495057;
        }
        
        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            margin: 5px 0;
        }
        
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .slider-group input[type="range"]::-webkit-slider-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #ddd;
            border-radius: 3px;
        }
        
        .slider-group input[type="range"]::-moz-range-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #ddd;
            border-radius: 3px;
            border: none;
        }
        
        .manual-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #dee2e6;
        }
        
        .manual-controls input[type="number"] {
            width: 80px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .manual-controls button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .manual-controls button:hover {
            background-color: #0056b3;
        }
        
        .slider-group span {
            color: #007bff;
            font-weight: bold;
            font-family: monospace;
        }
        
        .tensor-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .tensor-column h4 {
            background-color: #007bff;
            color: white;
            padding: 8px 12px;
            margin: 0 0 10px 0;
            border-radius: 3px;
        }
        
        .values-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 2px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            padding: 5px;
            background-color: #fafafa;
        }
        
        .value-cell {
            background-color: white;
            padding: 6px 8px;
            border: 1px solid #eee;
            border-radius: 2px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            text-align: right;
            cursor: help;
        }
        
        .value-cell:hover {
            background-color: #e3f2fd;
        }
        
        .tensor-info-display {
            background-color: #f1f3f4;
            padding: 10px;
            margin-top: 15px;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }
        
        .summary-stats {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .summary-stats h5 {
            margin: 0 0 10px 0;
            color: #495057;
            font-weight: bold;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #e9ecef;
        }
        
        .stat-item.highlight {
            background-color: #fff3cd;
            border-color: #ffeaa7;
            font-weight: bold;
        }
        
        .stat-label {
            color: #495057;
            font-size: 14px;
        }
        
        .stat-value {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #2c3e50;
            font-weight: bold;
        }
        
        .summary-stats.error {
            background-color: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }
        
        .summary-stats.single-model {
            background-color: #fff3cd;
            border-color: #ffc107;
        }
        
        .single-model-note {
            text-align: center;
            font-style: italic;
            color: #856404;
            margin-top: 10px;
            padding: 5px;
            background-color: #ffeaa7;
            border-radius: 3px;
        }
        
        .tensor-details.missing {
            background-color: #f8f9fa;
            color: #6c757d;
            font-style: italic;
        }
        
        .tensor-details.single-tensor {
            background-color: #d4edda;
            border-left-color: #28a745;
        }
        
        .missing-column {
            background-color: #f8f9fa;
            opacity: 0.6;
        }
        
        .missing-notice {
            padding: 20px;
            text-align: center;
            color: #6c757d;
            font-style: italic;
            background-color: #e9ecef;
            border-radius: 3px;
            margin: 10px;
        }
        
        .floating-header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: linear-gradient(135deg, #007bff, #28a745);
            color: white;
            padding: 10px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: none;
            border-radius: 0 0 8px 8px;
            margin-bottom: 20px;
        }
        
        .floating-header.visible {
            display: block;
        }
        
        .header-content {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            gap: 20px;
        }
        
        .model-info {
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            background: rgba(255,255,255,0.1);
            padding: 5px 10px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .model-info.model1 {
            text-align: left;
        }
        
        .model-info.model2 {
            text-align: right;
        }
        
        .vs-divider {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            color: #ffd700;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ML Model Tensor Debugger</h1>
        
        <div class="upload-section">
            <div class="drop-zone" id="model1-drop">
                <input type="file" id="model1-file" accept=".zip,.tar.gz,.tgz">
                <div class="drop-zone-text">Drop Model 1 archive here</div>
                <div class="file-info" id="model1-info"></div>
            </div>
            
            <div class="drop-zone" id="model2-drop">
                <input type="file" id="model2-file" accept=".zip,.tar.gz,.tgz">
                <div class="drop-zone-text">Drop Model 2 archive here</div>
                <div class="file-info" id="model2-info"></div>
            </div>
        </div>
        
        <button class="upload-btn" id="upload-btn" disabled>Compare Models</button>
        
        <div class="progress" id="progress">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        
        <div class="results" id="results">
            <div class="floating-header" id="floating-header">
                <div class="header-content">
                    <div class="model-info model1" id="floating-model1">Model 1</div>
                    <div class="vs-divider">VS</div>
                    <div class="model-info model2" id="floating-model2">Model 2</div>
                </div>
            </div>
            <div class="summary" id="summary"></div>
            <div style="text-align: center; margin: 20px 0; display: none;" id="control-buttons">
                <button class="upload-btn" onclick="collapseAll()" style="background-color: #6c757d;">
                    📉 Collapse All
                </button>
                <button class="upload-btn" onclick="expandAll()" style="background-color: #28a745; margin-left: 10px;">
                    📈 Expand All
                </button>
            </div>
            <div id="matches-container"></div>
        </div>
    </div>

    <script>
        let model1File = null;
        let model2File = null;
        
        // Setup drag and drop
        function setupDropZone(dropZoneId, fileInputId, infoId) {
            const dropZone = document.getElementById(dropZoneId);
            const fileInput = document.getElementById(fileInputId);
            const fileInfo = document.getElementById(infoId);
            
            dropZone.addEventListener('click', () => fileInput.click());
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    fileInput.files = files;
                    handleFileSelect(fileInput, dropZone, fileInfo);
                }
            });
            
            fileInput.addEventListener('change', () => {
                handleFileSelect(fileInput, dropZone, fileInfo);
            });
        }
        
        function handleFileSelect(fileInput, dropZone, fileInfo) {
            const file = fileInput.files[0];
            if (file) {
                dropZone.classList.add('file-loaded');
                fileInfo.textContent = `${file.name} (${formatFileSize(file.size)})`;
                
                if (fileInput.id === 'model1-file') {
                    model1File = file;
                } else {
                    model2File = file;
                }
                
                updateUploadButton();
            }
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function updateUploadButton() {
            const uploadBtn = document.getElementById('upload-btn');
            uploadBtn.disabled = !(model1File && model2File);
        }
        
        function showProgress() {
            document.getElementById('progress').style.display = 'block';
            document.getElementById('progress-bar').style.width = '0%';
        }
        
        function hideProgress() {
            document.getElementById('progress').style.display = 'none';
        }
        
        function updateProgress(percent) {
            document.getElementById('progress-bar').style.width = percent + '%';
        }
        
        async function uploadAndCompare() {
            showProgress();
            updateProgress(10);
            
            const formData = new FormData();
            formData.append('model1', model1File);
            formData.append('model2', model2File);
            
            try {
                updateProgress(50);
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                
                updateProgress(80);
                const result = await response.json();
                
                if (result.error) {
                    throw new Error(result.error);
                }
                
                updateProgress(90);
                await displayResults(result);
                updateProgress(100);
                
                setTimeout(hideProgress, 500);
                
            } catch (error) {
                hideProgress();
                document.getElementById('results').innerHTML = 
                    `<div class="error">Error: ${error.message}</div>`;
                document.getElementById('results').style.display = 'block';
            }
        }
        
        let globalMatches = []; // Store matches globally for tensor inspection

        async function displayResults(data) {
            const resultsDiv = document.getElementById('results');
            const summaryDiv = document.getElementById('summary');
            const matchesContainer = document.getElementById('matches-container');
            const floatingHeader = document.getElementById('floating-header');
            const floatingModel1 = document.getElementById('floating-model1');
            const floatingModel2 = document.getElementById('floating-model2');
            
            globalMatches = data.matches;
            
            // Update floating header with model names
            const model1Name = model1File ? model1File.name : 'Model 1';
            const model2Name = model2File ? model2File.name : 'Model 2';
            floatingModel1.textContent = model1Name;
            floatingModel2.textContent = model2Name;
            floatingHeader.classList.add('visible');
            
            summaryDiv.innerHTML = `
                <h3>Tensor Comparison Results</h3>
                <p>Model 1: ${data.model1_files} tensor files (${model1Name})</p>
                <p>Model 2: ${data.model2_files} tensor files (${model2Name})</p>
                <p>Matched pairs: ${data.matches.length}</p>
            `;
            
            matchesContainer.innerHTML = '';
            
            // Group matches by layer
            const layerGroups = {};
            data.matches.forEach((match, index) => {
                if (!layerGroups[match.layer_num]) {
                    layerGroups[match.layer_num] = [];
                }
                layerGroups[match.layer_num].push({...match, match_index: index});
            });
            
            // Display each layer group
            Object.keys(layerGroups).sort((a, b) => parseInt(a) - parseInt(b)).forEach(layerNum => {
                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer-group';
                layerDiv.innerHTML = `<h3>Layer ${layerNum}</h3>`;
                
                layerGroups[layerNum].forEach(match => {
                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'match-item collapsed'; // Start collapsed by default
                    matchDiv.setAttribute('data-match-index', match.match_index);
                    
                    // Generate summary statistics display
                    let summaryContent = '';
                    
                    if (match.match_type === 'both' && match.diff_stats && !match.diff_stats.error) {
                        if (match.diff_stats.shape_match) {
                            // Check if this looks like a potential manual mapping case
                            let manualMappingHint = '';
                            if (match.model1_data && match.model2_data) {
                                const shape1 = match.model1_data.shape;
                                const shape2 = match.model2_data.shape;
                                const elements1 = shape1.reduce((a, b) => a * b, 1);
                                const elements2 = shape2.reduce((a, b) => a * b, 1);
                                
                                // Check if shapes are very different but same elements AND poor similarity
                                const shapesDifferent = JSON.stringify(shape1) !== JSON.stringify(shape2);
                                const poorSimilarity = match.diff_stats.cosine_sim < 0.5;
                                const highDifference = match.diff_stats.abs_diff_max > 1.0;
                                
                                if (elements1 === elements2 && shapesDifferent && (poorSimilarity || highDifference)) {
                                    manualMappingHint = `
                                        <div style="margin-top: 10px; padding: 8px; background-color: #e3f2fd; border-radius: 4px; color: #1565c0; border-left: 4px solid #2196f3;">
                                            💡 <strong>Manual Mapping Recommended:</strong> These tensors have identical element counts (${elements1}) but very different shapes and poor similarity. 
                                            The automatic reshaping may not be finding the correct alignment. 
                                            <strong>Try "🔧 Manual Mapping"</strong> to manually explore dimension combinations!
                                        </div>
                                    `;
                                }
                            }
                            
                            summaryContent = `
                                <div class="summary-stats">
                                    <h5>Summary Statistics</h5>
                                    <div class="stats-grid">
                                        <div class="stat-item">
                                            <span class="stat-label">Model 1 Mean:</span>
                                            <span class="stat-value">${match.model1_data.mean.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Model 2 Mean:</span>
                                            <span class="stat-value">${match.model2_data.mean.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Model 1 Std:</span>
                                            <span class="stat-value">${match.model1_data.std.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Model 2 Std:</span>
                                            <span class="stat-value">${match.model2_data.std.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item highlight">
                                            <span class="stat-label">Max Difference:</span>
                                            <span class="stat-value">${match.diff_stats.abs_diff_max.toFixed(6)}</span>
                                        </div>
                                        <div class="stat-item highlight">
                                            <span class="stat-label">Cosine Similarity:</span>
                                            <span class="stat-value">${match.diff_stats.cosine_sim.toFixed(6)}</span>
                                        </div>
                                    </div>
                                    ${manualMappingHint}
                                </div>
                            `;
                        } else {
                            summaryContent = `
                                <div class="summary-stats error">
                                    <strong>Shape Mismatch:</strong><br>
                                    Model 1: [${match.diff_stats.shape1.join(', ')}]<br>
                                    Model 2: [${match.diff_stats.shape2.join(', ')}]<br>
                                    <em>${match.diff_stats.error || 'Cannot reshape for tensor parallel compatibility'}</em>
                                </div>
                            `;
                        }
                    } else if (match.match_type === 'model1_only') {
                        summaryContent = `
                            <div class="summary-stats single-model">
                                <h5>Single Model Statistics</h5>
                                <div class="stats-grid">
                                    <div class="stat-item">
                                        <span class="stat-label">Model 1 Mean:</span>
                                        <span class="stat-value">${match.model1_data.mean.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 1 Std:</span>
                                        <span class="stat-value">${match.model1_data.std.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 1 Min:</span>
                                        <span class="stat-value">${match.model1_data.min.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 1 Max:</span>
                                        <span class="stat-value">${match.model1_data.max.toFixed(6)}</span>
                                    </div>
                                </div>
                                <div class="single-model-note">⚠️ Only available in Model 1</div>
                            </div>
                        `;
                    } else if (match.match_type === 'model2_only') {
                        summaryContent = `
                            <div class="summary-stats single-model">
                                <h5>Single Model Statistics</h5>
                                <div class="stats-grid">
                                    <div class="stat-item">
                                        <span class="stat-label">Model 2 Mean:</span>
                                        <span class="stat-value">${match.model2_data.mean.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 2 Std:</span>
                                        <span class="stat-value">${match.model2_data.std.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 2 Min:</span>
                                        <span class="stat-value">${match.model2_data.min.toFixed(6)}</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Model 2 Max:</span>
                                        <span class="stat-value">${match.model2_data.max.toFixed(6)}</span>
                                    </div>
                                </div>
                                <div class="single-model-note">⚠️ Only available in Model 2</div>
                            </div>
                        `;
                    } else if (match.diff_stats && match.diff_stats.error) {
                        // Check if this might be a reshapeable tensor case
                        const hasReshapeHint = match.diff_stats.error && match.diff_stats.error.includes('reshape');
                        let reshapeHintText = '';
                        
                        if (hasReshapeHint && match.model1_data && match.model2_data) {
                            const shape1 = match.model1_data.shape;
                            const shape2 = match.model2_data.shape;
                            const elements1 = shape1.reduce((a, b) => a * b, 1);
                            const elements2 = shape2.reduce((a, b) => a * b, 1);
                            
                            if (elements1 === elements2) {
                                reshapeHintText = `
                                    <div style="margin-top: 10px; padding: 8px; background-color: #e3f2fd; border-radius: 4px; color: #1565c0; border-left: 4px solid #2196f3;">
                                        💡 <strong>Tip:</strong> These tensors have the same number of elements (${elements1}) but different shapes. 
                                        They might contain identical data arranged differently. 
                                        <strong>Try "🔧 Manual Mapping"</strong> to explore different dimension combinations!
                                    </div>
                                `;
                            }
                        }
                        
                        summaryContent = `
                            <div class="summary-stats error">
                                <strong>Error:</strong> ${match.diff_stats.error}
                                ${reshapeHintText}
                            </div>
                        `;
                    }

                    // Generate tensor info display based on match type
                    let tensorInfoContent = '';
                    if (match.match_type === 'both') {
                        tensorInfoContent = `
                            <div class="tensor-details">
                                <strong>Model 1:</strong> ${match.model1_file}<br>
                                Shape: [${match.model1_data.shape.join(', ')}]
                            </div>
                            <div class="tensor-details">
                                <strong>Model 2:</strong> ${match.model2_file}<br>
                                Shape: [${match.model2_data.shape.join(', ')}]
                            </div>
                        `;
                    } else if (match.match_type === 'model1_only') {
                        tensorInfoContent = `
                            <div class="tensor-details single-tensor">
                                <strong>Model 1:</strong> ${match.model1_file}<br>
                                Shape: [${match.model1_data.shape.join(', ')}]
                            </div>
                            <div class="tensor-details missing">
                                <strong>Model 2:</strong> <em>Not available</em>
                            </div>
                        `;
                    } else if (match.match_type === 'model2_only') {
                        tensorInfoContent = `
                            <div class="tensor-details missing">
                                <strong>Model 1:</strong> <em>Not available</em>
                            </div>
                            <div class="tensor-details single-tensor">
                                <strong>Model 2:</strong> ${match.model2_file}<br>
                                Shape: [${match.model2_data.shape.join(', ')}]
                            </div>
                        `;
                    }

                    // Create a summary for the collapsed view
                    let quickSummary = '';
                    if (match.match_type === 'both' && match.diff_stats && !match.diff_stats.error && match.diff_stats.shape_match) {
                        quickSummary = `<span class="match-summary">Max Diff: ${match.diff_stats.abs_diff_max.toFixed(6)}, Cosine Sim: ${match.diff_stats.cosine_sim.toFixed(4)}</span>`;
                    } else if (match.match_type !== 'both') {
                        quickSummary = `<span class="match-summary">Single model only</span>`;
                    } else if (match.diff_stats && match.diff_stats.error) {
                        quickSummary = `<span class="match-summary">Error: ${match.diff_stats.error}</span>`;
                    }

                    matchDiv.innerHTML = `
                        <div class="match-header" onclick="toggleMatch(${match.match_index})">
                            <div>
                                <span>${match.stage_display}</span>
                                ${quickSummary}
                            </div>
                            <span class="collapse-indicator">▼</span>
                        </div>
                        <div class="match-content">
                            <div class="tensor-info">
                                ${tensorInfoContent}
                            </div>
                            ${summaryContent}
                            <div class="tensor-values">
                                <button class="inspect-btn" onclick="showTensorValues(${match.match_index})">
                                    Inspect Raw Tensor Values
                                </button>
                                ${match.match_type === 'both' ? `<button class="inspect-btn" onclick="jumpToMaxDiffInTensor(${match.match_index})" style="background-color: #dc3545; margin-left: 10px;">🎯 Jump to Max Diff</button>` : ''}
                                ${match.match_type === 'both' ? `<button class="inspect-btn" onclick="quickManualMapping(${match.match_index})" style="background-color: #17a2b8; margin-left: 10px;">🔧 Manual Mapping</button>` : ''}
                                <div class="values-container" id="values-${match.match_index}" style="display: none;">
                                    
                                    <!-- Dimension Mapping Controls -->
                                    <div class="dimension-mapping" id="dimension-mapping-${match.match_index}" style="display: none; margin-bottom: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 5px;">
                                        <h4>Manual Dimension Mapping</h4>
                                        <p>Control which dimensions to slice for each tensor independently:</p>
                                        <div id="mapping-controls-${match.match_index}"></div>
                                        <button onclick="applyDimensionMapping(${match.match_index})" style="margin-top: 10px; background-color: #28a745;">Apply Mapping</button>
                                        <button onclick="toggleMappingMode(${match.match_index})" style="margin-top: 10px; margin-left: 10px; background-color: #6c757d;">Switch to Auto Mode</button>
                                    </div>
                                    
                                    <!-- Original slice controls -->
                                    <div class="slice-controls" id="auto-controls-${match.match_index}">
                                        <div id="dimension-controls-${match.match_index}"></div>
                                        <div class="slider-group">
                                            <label for="count-slider-${match.match_index}">Values to Show: <span id="count-value-${match.match_index}">10</span></label>
                                            <input type="range" id="count-slider-${match.match_index}" min="1" max="100" value="10" 
                                                   oninput="updateSliderValue(${match.match_index}, 'count')" 
                                                   onchange="updateTensorValues(${match.match_index})">
                                        </div>
                                        <div class="manual-controls">
                                            <input type="number" id="count-input-${match.match_index}" value="10" min="1" max="100" 
                                                   onchange="syncSliderFromInput(${match.match_index}, 'count')" placeholder="Count">
                                            <button onclick="updateTensorValues(${match.match_index})">Update</button>
                                            <button onclick="resetDimensionSliders(${match.match_index})" style="background-color: #6c757d; margin-left: 10px;">Reset</button>
                                            <button onclick="toggleMappingMode(${match.match_index})" style="background-color: #007bff; margin-left: 10px;">Manual Mapping</button>
                                        </div>
                                    </div>
                                    <div id="tensor-display-${match.match_index}"></div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    layerDiv.appendChild(matchDiv);
                });
                
                matchesContainer.appendChild(layerDiv);
            });
            
            resultsDiv.style.display = 'block';
            
            // Show the control buttons
            document.getElementById('control-buttons').style.display = 'block';
        }
        
        async function showTensorValues(matchIndex) {
            const valuesContainer = document.getElementById(`values-${matchIndex}`);
            if (valuesContainer.style.display === 'none') {
                valuesContainer.style.display = 'block';
                // Initialize slider ranges based on tensor size when first shown
                await initializeSliderRanges(matchIndex);
                await updateTensorValues(matchIndex);
            } else {
                valuesContainer.style.display = 'none';
            }
        }
        
        async function initializeSliderRanges(matchIndex) {
            // Get the ACTUAL tensor shape after TP-aware reshaping from the backend
            if (globalMatches[matchIndex]) {
                const match = globalMatches[matchIndex];
                // Make a quick request to get the final tensor info after any reshaping
                try {
                    const response = await fetch('/get_tensor_values', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            match_index: matchIndex,
                            dimension_indices: [],
                            count: 1,
                            get_final_shape: true  // Request final shape after reshaping
                        }),
                    });
                    const result = await response.json();
                    
                    if (!result.error && result.tensor_shape) {
                        // Use the final tensor shape from backend (after TP-aware reshaping)
                        console.log(`Creating sliders for final shape: [${result.tensor_shape.join(', ')}]`);
                        createDimensionSliders(matchIndex, result.tensor_shape, result.original_shapes);
                    } else {
                        // Fallback for scalar or error cases
                        createDimensionSliders(matchIndex, result.tensor_shape || [], null);
                    }
                } catch (error) {
                    console.log('Could not initialize slider range:', error);
                    createDimensionSliders(matchIndex, [], null);
                }
            }
        }
        
        function createDimensionSliders(matchIndex, tensorShape, originalShapes) {
            const dimensionContainer = document.getElementById(`dimension-controls-${matchIndex}`);
            
            if (tensorShape.length === 0) {
                // Scalar tensor - no dimension sliders needed
                dimensionContainer.innerHTML = '<p><em>Scalar value - no dimensions to slice</em></p>';
                return;
            }
            
            if (tensorShape.length === 1) {
                // 1D tensor - single dimension slider
                dimensionContainer.innerHTML = `
                    <div class="slider-group">
                        <label for="dim0-slider-${matchIndex}">Index (Dimension 0): <span id="dim0-value-${matchIndex}">0</span></label>
                        <input type="range" id="dim0-slider-${matchIndex}" min="0" max="${tensorShape[0] - 1}" value="0" 
                               oninput="updateDimensionSlider(${matchIndex}, 0)" 
                               onchange="updateTensorValues(${matchIndex})">
                    </div>
                `;
                return;
            }
            
            // Multi-dimensional tensor - create sliders for the FINAL tensor shape
            let slidersHTML = '<p><strong>Dimension Sliders (Final Shape):</strong></p>';
            
            // Show original shapes if available
            if (originalShapes) {
                slidersHTML += `<p><em>Original shapes: [${originalShapes.shape1.join(', ')}] vs [${originalShapes.shape2.join(', ')}] → Final: [${tensorShape.join(', ')}]</em></p>`;
            }
            
            // Create sliders for each dimension of the final tensor shape
            for (let i = 0; i < tensorShape.length; i++) {
                const dimSize = tensorShape[i];
                slidersHTML += `
                    <div class="slider-group">
                        <label for="dim${i}-slider-${matchIndex}">Dim ${i} (size ${dimSize}): <span id="dim${i}-value-${matchIndex}">0</span></label>
                        <input type="range" id="dim${i}-slider-${matchIndex}" min="0" max="${dimSize - 1}" value="0" 
                               oninput="updateDimensionSlider(${matchIndex}, ${i})" 
                               onchange="updateTensorValues(${matchIndex})">
                    </div>
                `;
            }
            
            dimensionContainer.innerHTML = slidersHTML;
        }
        
        function updateDimensionSlider(matchIndex, dimensionIndex) {
            const slider = document.getElementById(`dim${dimensionIndex}-slider-${matchIndex}`);
            const valueSpan = document.getElementById(`dim${dimensionIndex}-value-${matchIndex}`);
            
            if (slider && valueSpan) {
                valueSpan.textContent = slider.value;
            }
        }
        
        function getDimensionIndices(matchIndex) {
            const indices = [];
            const dimensionContainer = document.getElementById(`dimension-controls-${matchIndex}`);
            const sliders = dimensionContainer.querySelectorAll('input[type="range"]');
            
            // Simply get the slider values in order - they now correspond directly to final tensor dimensions
            sliders.forEach((slider, index) => {
                const value = parseInt(slider.value) || 0;
                indices.push(value);
            });
            
            return indices;
        }
        
        function resetDimensionSliders(matchIndex) {
            const dimensionContainer = document.getElementById(`dimension-controls-${matchIndex}`);
            const sliders = dimensionContainer.querySelectorAll('input[type="range"]');
            
            sliders.forEach((slider, index) => {
                slider.value = 0;
                updateDimensionSlider(matchIndex, index);
            });
            
            updateTensorValues(matchIndex);
        }
        
        function updateSliderValue(matchIndex, type) {
            if (type === 'count') {
                const slider = document.getElementById(`count-slider-${matchIndex}`);
                const valueSpan = document.getElementById(`count-value-${matchIndex}`);
                const input = document.getElementById(`count-input-${matchIndex}`);
                valueSpan.textContent = slider.value;
                input.value = slider.value;
            }
        }
        
        function syncSliderFromInput(matchIndex, type) {
            if (type === 'count') {
                const input = document.getElementById(`count-input-${matchIndex}`);
                const slider = document.getElementById(`count-slider-${matchIndex}`);
                const valueSpan = document.getElementById(`count-value-${matchIndex}`);
                const value = Math.max(1, Math.min(100, parseInt(input.value) || 10));
                slider.value = value;
                valueSpan.textContent = value;
                input.value = value;
                updateTensorValues(matchIndex);
            }
        }
        
        async function updateTensorValues(matchIndex) {
            const countSlider = document.getElementById(`count-slider-${matchIndex}`);
            const displayDiv = document.getElementById(`tensor-display-${matchIndex}`);
            
            const dimensionIndices = getDimensionIndices(matchIndex);
            const count = parseInt(countSlider.value) || 10;
            
            displayDiv.innerHTML = '<div class="loading">Loading tensor values...</div>';
            
            try {
                const response = await fetch('/get_tensor_values', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        match_index: matchIndex,
                        dimension_indices: dimensionIndices,
                        count: count
                    }),
                });
                
                const result = await response.json();
                
                if (result.error) {
                    displayDiv.innerHTML = `<div class="error">Error: ${result.error}</div>`;
                    return;
                }
                
                // Initialize variables needed for display
                const indexOffset = 0; // For tooltip indexing
                
                // Define color functions for all cases
                const getBackgroundColor = (value, allValues = null) => {
                    const absValue = Math.abs(value);
                    
                    // Calculate intensity based on magnitude if we have all values for context
                    let intensity = 0.5; // Default medium intensity
                    if (allValues && allValues.length > 0) {
                        const maxAbs = Math.max(...allValues.map(v => Math.abs(v)));
                        const minAbs = Math.min(...allValues.map(v => Math.abs(v)));
                        if (maxAbs > minAbs) {
                            intensity = (absValue - minAbs) / (maxAbs - minAbs);
                        }
                    }
                    
                    if (value < 0) {
                        // Blue gradient: light blue to medium blue based on magnitude
                        const red = Math.floor(173 - (173 - 100) * intensity);   // 173 (light blue) to 100 (medium blue)
                        const green = Math.floor(216 - (216 - 149) * intensity); // 216 (light blue) to 149 (medium blue)  
                        const blue = Math.floor(230 - (230 - 237) * intensity);  // 230 (light blue) to 237 (medium blue)
                        return `rgb(${red}, ${green}, ${blue})`;
                    } else {
                        // Orange gradient: light orange to dark orange based on magnitude
                        const red = Math.floor(255 - (255 - 255) * intensity);   // 255 (light orange) to 255 (dark orange)
                        const green = Math.floor(228 - (228 - 140) * intensity); // 228 (light orange) to 140 (dark orange)
                        const blue = Math.floor(181 - (181 - 0) * intensity);    // 181 (light orange) to 0 (dark orange)
                        return `rgb(${red}, ${green}, ${blue})`;
                    }
                };
                
                const getBorderColor = (diff, maxDiffValue) => {
                    if (!maxDiffValue || maxDiffValue === 0) return '#90EE90'; // Light green if no difference
                    const normalizationFactor = 0.5; // 0.5 difference = dark color
                    const intensity = Math.min(diff / normalizationFactor, 1.0); // Cap at 1.0
                    
                    // Green to orange gradient for borders
                    const red = Math.floor(144 + (255 - 144) * intensity);   // 144 (light green) to 255 (orange)
                    const green = Math.floor(238 - (84 * intensity));        // 238 (light green) to 154 (orange)
                    const blue = Math.floor(144 - (144 * intensity));        // 144 (light green) to 0 (orange)
                    
                    return `rgb(${red}, ${green}, ${blue})`;
                };
                
                // Handle single model displays
                let tensorComparisonContent = '';
                
                if (result.tensor1_values && result.tensor2_values) {
                    // Both models have data - calculate differences and color code
                    const differences = result.tensor1_values.map((val1, idx) => 
                        Math.abs(val1 - result.tensor2_values[idx])
                    );
                    const maxDiff = Math.max(...differences);
                    const normalizationFactor = 0.5; // 0.5 difference = dark color
                    
                    // Store max difference for this tensor globally
                    if (!window.globalMaxDifferences) {
                        window.globalMaxDifferences = [];
                    }
                    window.globalMaxDifferences[matchIndex] = {
                        maxDiff: maxDiff,
                        layer: globalMatches[matchIndex]?.layer_num,
                        stage: globalMatches[matchIndex]?.stage_display,
                        matchIndex: matchIndex
                    };
                    
                    tensorComparisonContent = `
                        <div class="tensor-comparison">
                            <div class="tensor-column">
                                <h4>Model 1 Values</h4>
                                <div class="values-grid">
                                    ${result.tensor1_values.map((val, idx) => {
                                        const diff = differences[idx];
                                        const bgColor = getBackgroundColor(val, result.tensor1_values);
                                        const borderColor = getBorderColor(diff, maxDiff);
                                        return `<div class="value-cell" 
                                                style="background-color: ${bgColor}; border: 2px solid ${borderColor};" 
                                                title="Index: ${indexOffset + idx}, Value: ${val.toFixed(6)}, Diff: ${diff.toFixed(6)}">${val.toFixed(6)}</div>`;
                                    }).join('')}
                                </div>
                            </div>
                            <div class="tensor-column">
                                <h4>Model 2 Values</h4>
                                <div class="values-grid">
                                    ${result.tensor2_values.map((val, idx) => {
                                        const diff = differences[idx];
                                        const bgColor = getBackgroundColor(val, result.tensor2_values);
                                        const borderColor = getBorderColor(diff, maxDiff);
                                        return `<div class="value-cell" 
                                                style="background-color: ${bgColor}; border: 2px solid ${borderColor};" 
                                                title="Index: ${indexOffset + idx}, Value: ${val.toFixed(6)}, Diff: ${diff.toFixed(6)}">${val.toFixed(6)}</div>`;
                                    }).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                } else if (result.tensor1_values) {
                    // Only Model 1 has data
                    tensorComparisonContent = `
                        <div class="tensor-comparison single-model">
                            <div class="tensor-column">
                                <h4>Model 1 Values</h4>
                                <div class="values-grid">
                                    ${result.tensor1_values.map((val, idx) => {
                                        const bgColor = getBackgroundColor(val, result.tensor1_values);
                                        return `<div class="value-cell" 
                                                style="background-color: ${bgColor}; border: 2px solid #90EE90;" 
                                                title="Index: ${indexOffset + idx}, Value: ${val.toFixed(6)}">${val.toFixed(6)}</div>`;
                                    }).join('')}
                                </div>
                            </div>
                            <div class="tensor-column missing-column">
                                <h4>Model 2 Values</h4>
                                <div class="missing-notice">Not available in Model 2</div>
                            </div>
                        </div>
                    `;
                } else if (result.tensor2_values) {
                    // Only Model 2 has data
                    tensorComparisonContent = `
                        <div class="tensor-comparison single-model">
                            <div class="tensor-column missing-column">
                                <h4>Model 1 Values</h4>
                                <div class="missing-notice">Not available in Model 1</div>
                            </div>
                            <div class="tensor-column">
                                <h4>Model 2 Values</h4>
                                <div class="values-grid">
                                    ${result.tensor2_values.map((val, idx) => {
                                        const bgColor = getBackgroundColor(val, result.tensor2_values);
                                        return `<div class="value-cell" 
                                                style="background-color: ${bgColor}; border: 2px solid #90EE90;" 
                                                title="Index: ${indexOffset + idx}, Value: ${val.toFixed(6)}">${val.toFixed(6)}</div>`;
                                    }).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                const valueCount = result.tensor1_values ? result.tensor1_values.length : result.tensor2_values.length;
                const dimensionInfo = dimensionIndices.length > 0 ? `at indices [${dimensionIndices.join(', ')}]` : 'flattened view';
                
                displayDiv.innerHTML = `
                    ${tensorComparisonContent}
                    <div class="tensor-info-display">
                        <p><strong>Shape:</strong> [${result.tensor_shape.join(', ')}]</p>
                        <p><strong>Display Type:</strong> ${result.display_type}</p>
                        <p><strong>Viewing:</strong> ${valueCount} values ${dimensionInfo}</p>
                        ${result.slice_info ? `<p><strong>Slice Details:</strong> ${result.slice_info}</p>` : ''}
                    </div>
                `;
                
            } catch (error) {
                displayDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
            }
        }
        
        async function jumpToMaxDiffInTensor(matchIndex) {
            // First, expand the tensor values container if it's not already visible
            const valuesContainer = document.getElementById(`values-${matchIndex}`);
            if (valuesContainer && valuesContainer.style.display === 'none') {
                await showTensorValues(matchIndex);
            }
            
            // Make a request to get the argmax coordinates
            try {
                const response = await fetch('/get_tensor_values', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        match_index: matchIndex,
                        dimension_indices: [],
                        count: 1,
                        get_argmax: true  // Request argmax coordinates
                    }),
                });
                
                const result = await response.json();
                
                if (result.error) {
                    alert(`Error: ${result.error}`);
                    return;
                }
                
                if (!result.argmax_coordinates || result.argmax_coordinates.length === 0) {
                    // No argmax available for this tensor (might be single-model or scalar)
                    alert('No maximum difference location available for this tensor.');
                    return;
                }
                
                const argmaxCoords = result.argmax_coordinates;
                
                // Update dimension sliders to show the argmax position
                const dimensionContainer = document.getElementById(`dimension-controls-${matchIndex}`);
                const sliders = dimensionContainer.querySelectorAll('input[type="range"]');
                
                // Set each dimension slider to the argmax coordinate
                sliders.forEach((slider, dimIndex) => {
                    if (dimIndex < argmaxCoords.length) {
                        slider.value = argmaxCoords[dimIndex];
                        updateDimensionSlider(matchIndex, dimIndex);
                    }
                });
                
                // Update tensor values with the new position
                await updateTensorValues(matchIndex);
                
                // Scroll to the display and highlight it
                const displayDiv = document.getElementById(`tensor-display-${matchIndex}`);
                if (displayDiv) {
                    displayDiv.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'start' 
                    });
                    
                    // Highlight the tensor display
                    displayDiv.style.border = '3px solid #ff4444';
                    setTimeout(() => {
                        displayDiv.style.border = '';
                    }, 3000);
                    
                    // Show success message
                    const coords = argmaxCoords.join(', ');
                    const tempMessage = document.createElement('div');
                    tempMessage.innerHTML = `<div style="background: #28a745; color: white; padding: 10px; border-radius: 5px; margin: 10px 0; text-align: center;">🎯 Jumped to max difference at coordinates [${coords}]</div>`;
                    displayDiv.insertBefore(tempMessage, displayDiv.firstChild);
                    
                    setTimeout(() => {
                        tempMessage.remove();
                    }, 3000);
                }
                
            } catch (error) {
                alert(`Error finding max difference: ${error.message}`);
            }
        }
        
        function collapseAll() {
            const matchItems = document.querySelectorAll('.match-item');
            matchItems.forEach(item => {
                item.classList.add('collapsed');
            });
        }
        
        function expandAll() {
            const matchItems = document.querySelectorAll('.match-item');
            matchItems.forEach(item => {
                item.classList.remove('collapsed');
            });
        }
        
        function toggleMatch(matchIndex) {
            const matchItem = document.querySelector(`[data-match-index="${matchIndex}"]`);
            if (matchItem) {
                matchItem.classList.toggle('collapsed');
            }
        }
        
        // Manual dimension mapping functions
        let mappingMode = {}; // Track mapping mode per match
        let originalShapes = {}; // Store original shapes per match
        
        function toggleMappingMode(matchIndex) {
            const mappingDiv = document.getElementById(`dimension-mapping-${matchIndex}`);
            const autoDiv = document.getElementById(`auto-controls-${matchIndex}`);
            
            if (!mappingMode[matchIndex]) {
                // Switch to manual mapping mode
                mappingDiv.style.display = 'block';
                autoDiv.style.display = 'none';
                mappingMode[matchIndex] = true;
                initializeDimensionMapping(matchIndex);
            } else {
                // Switch to auto mode
                mappingDiv.style.display = 'none';
                autoDiv.style.display = 'block';
                mappingMode[matchIndex] = false;
            }
        }
        
        async function initializeDimensionMapping(matchIndex) {
            const mappingContainer = document.getElementById(`mapping-controls-${matchIndex}`);
            
            try {
                // Get original tensor shapes before any reshaping
                const response = await fetch('/get_tensor_shapes', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        match_index: matchIndex
                    }),
                });
                const result = await response.json();
                
                if (result.error) {
                    mappingContainer.innerHTML = `<p>Error: ${result.error}</p>`;
                    return;
                }
                
                // Store for later use
                originalShapes[matchIndex] = result;
                
                let mappingHTML = '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">';
                
                // Tensor 1 controls
                if (result.tensor1_shape) {
                    mappingHTML += `
                        <div>
                            <h5>Tensor 1 (${result.tensor1_name || 'Model 1'})</h5>
                            <p><em>Original shape: [${result.tensor1_shape.join(', ')}]</em></p>
                            ${createTensorMappingControls(matchIndex, 1, result.tensor1_shape)}
                        </div>
                    `;
                }
                
                // Tensor 2 controls
                if (result.tensor2_shape) {
                    mappingHTML += `
                        <div>
                            <h5>Tensor 2 (${result.tensor2_name || 'Model 2'})</h5>
                            <p><em>Original shape: [${result.tensor2_shape.join(', ')}]</em></p>
                            ${createTensorMappingControls(matchIndex, 2, result.tensor2_shape)}
                        </div>
                    `;
                }
                
                mappingHTML += '</div>';
                
                // Add values to show control and convenience buttons
                mappingHTML += `
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <label for="manual-count-slider-${matchIndex}" style="font-weight: bold;">
                                    Values to Show: <span id="manual-count-value-${matchIndex}">10</span>
                                </label>
                                <input type="range" 
                                       id="manual-count-slider-${matchIndex}" 
                                       min="1" 
                                       max="100" 
                                       value="10" 
                                       style="width: 120px;"
                                       oninput="updateManualCountSlider(${matchIndex})"
                                       onchange="updateManualCountSlider(${matchIndex})">
                                <input type="number" 
                                       id="manual-count-input-${matchIndex}" 
                                       value="10" 
                                       min="1" 
                                       max="100" 
                                       style="width: 50px;"
                                       onchange="syncManualCountFromInput(${matchIndex})">
                            </div>
                            <div>
                                <label>
                                    <input type="checkbox" id="auto-update-${matchIndex}" checked onchange="toggleAutoUpdate(${matchIndex})"> 
                                    Auto-update on slider change
                                </label>
                            </div>
                        </div>
                        <div style="margin-top: 10px;">
                            <button onclick="resetManualSliders(${matchIndex})" style="background-color: #6c757d; margin-right: 10px;">Reset All to 0</button>
                            <button onclick="copyTensor1ToTensor2(${matchIndex})" style="background-color: #17a2b8; margin-right: 10px;">Copy T1→T2 Settings</button>
                            ${result.tensor1_shape && result.tensor2_shape ? `<button onclick="tryCommonMappings(${matchIndex})" style="background-color: #ffc107; color: black;">Try Common Mappings</button>` : ''}
                        </div>
                    </div>
                `;
                
                mappingContainer.innerHTML = mappingHTML;
                
            } catch (error) {
                console.error('Error initializing dimension mapping:', error);
                mappingContainer.innerHTML = `<p>Error loading tensor shapes: ${error.message}</p>`;
            }
        }
        
        function createTensorMappingControls(matchIndex, tensorNum, shape) {
            let html = '';
            
            for (let i = 0; i < shape.length; i++) {
                html += `
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; font-weight: bold; margin-bottom: 4px;">
                            Dim ${i} (size ${shape[i]}): <span id="t${tensorNum}-dim${i}-value-${matchIndex}">0</span>
                        </label>
                        <input type="range" 
                               id="t${tensorNum}-dim${i}-slider-${matchIndex}" 
                               min="0" 
                               max="${shape[i] - 1}" 
                               value="0" 
                               style="width: 200px; margin-right: 10px;"
                               oninput="updateManualSlider(${matchIndex}, ${tensorNum}, ${i})"
                               onchange="updateManualSlider(${matchIndex}, ${tensorNum}, ${i})">
                        <input type="number" 
                               id="t${tensorNum}-dim${i}-input-${matchIndex}" 
                               value="0" 
                               min="0" 
                               max="${shape[i] - 1}" 
                               style="width: 50px; margin-left: 5px;"
                               onchange="syncManualSliderFromInput(${matchIndex}, ${tensorNum}, ${i})">
                        <span style="font-size: 12px; color: #666; margin-left: 5px;">(0-${shape[i] - 1})</span>
                    </div>
                `;
            }
            
            return html;
        }
        
        function updateManualSlider(matchIndex, tensorNum, dimIndex) {
            const slider = document.getElementById(`t${tensorNum}-dim${dimIndex}-slider-${matchIndex}`);
            const valueSpan = document.getElementById(`t${tensorNum}-dim${dimIndex}-value-${matchIndex}`);
            const input = document.getElementById(`t${tensorNum}-dim${dimIndex}-input-${matchIndex}`);
            
            if (slider && valueSpan && input) {
                const value = slider.value;
                valueSpan.textContent = value;
                input.value = value;
                
                // Auto-update if enabled
                const autoUpdateCheckbox = document.getElementById(`auto-update-${matchIndex}`);
                if (autoUpdateCheckbox && autoUpdateCheckbox.checked) {
                    // Debounce the auto-update to avoid too many requests
                    clearTimeout(window[`autoUpdateTimer_${matchIndex}`]);
                    window[`autoUpdateTimer_${matchIndex}`] = setTimeout(() => {
                        applyDimensionMapping(matchIndex);
                    }, 500); // 500ms delay
                }
            }
        }
        
        function syncManualSliderFromInput(matchIndex, tensorNum, dimIndex) {
            const slider = document.getElementById(`t${tensorNum}-dim${dimIndex}-slider-${matchIndex}`);
            const valueSpan = document.getElementById(`t${tensorNum}-dim${dimIndex}-value-${matchIndex}`);
            const input = document.getElementById(`t${tensorNum}-dim${dimIndex}-input-${matchIndex}`);
            
            if (slider && valueSpan && input) {
                let value = parseInt(input.value) || 0;
                const max = parseInt(slider.max);
                const min = parseInt(slider.min);
                
                // Clamp value to slider range
                value = Math.max(min, Math.min(max, value));
                
                slider.value = value;
                valueSpan.textContent = value;
                input.value = value; // Update input in case it was clamped
            }
        }
        
        async function applyDimensionMapping(matchIndex) {
            const shapes = originalShapes[matchIndex];
            if (!shapes) {
                alert('Tensor shapes not loaded. Please try again.');
                return;
            }
            
            // Collect dimension indices for both tensors
            const tensor1_indices = [];
            const tensor2_indices = [];
            
            if (shapes.tensor1_shape) {
                for (let i = 0; i < shapes.tensor1_shape.length; i++) {
                    const slider = document.getElementById(`t1-dim${i}-slider-${matchIndex}`);
                    if (slider) {
                        tensor1_indices.push(parseInt(slider.value) || 0);
                    }
                }
            }
            
            if (shapes.tensor2_shape) {
                for (let i = 0; i < shapes.tensor2_shape.length; i++) {
                    const slider = document.getElementById(`t2-dim${i}-slider-${matchIndex}`);
                    if (slider) {
                        tensor2_indices.push(parseInt(slider.value) || 0);
                    }
                }
            }
            
            const count = parseInt(document.getElementById(`manual-count-input-${matchIndex}`).value) || 10;
            
            try {
                const response = await fetch('/get_tensor_values_manual', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        match_index: matchIndex,
                        tensor1_indices: tensor1_indices,
                        tensor2_indices: tensor2_indices,
                        count: count
                    }),
                });
                
                const result = await response.json();
                
                if (result.error) {
                    alert(`Error: ${result.error}`);
                    return;
                }
                
                displayManualTensorValues(matchIndex, result);
                
            } catch (error) {
                console.error('Error applying dimension mapping:', error);
                alert(`Error: ${error.message}`);
            }
        }
        
        function displayManualTensorValues(matchIndex, result) {
            const displayDiv = document.getElementById(`tensor-display-${matchIndex}`);
            
            let html = '<div class="tensor-comparison">';
            
            // Add summary statistics if available
            if (result.summary_stats && !result.summary_stats.error) {
                const stats = result.summary_stats;
                const isIdentical = stats.comparison_info.values_identical;
                const maxDiff = stats.difference_stats.abs_diff_max;
                const cosineSim = stats.difference_stats.cosine_sim;
                
                html += `<div class="summary-stats" style="margin-bottom: 15px; ${isIdentical ? 'background-color: #e8f5e8; border-color: #28a745;' : ''}">`;
                html += '<h5>Manual Mapping Statistics</h5>';
                html += '<div class="stats-grid">';
                
                // Tensor 1 stats
                html += `<div class="stat-item">`;
                html += `<span class="stat-label">Model 1 Mean:</span>`;
                html += `<span class="stat-value">${stats.tensor1_stats.mean.toFixed(6)}</span>`;
                html += `</div>`;
                html += `<div class="stat-item">`;
                html += `<span class="stat-label">Model 2 Mean:</span>`;
                html += `<span class="stat-value">${stats.tensor2_stats.mean.toFixed(6)}</span>`;
                html += `</div>`;
                
                // Difference stats (highlighted)
                html += `<div class="stat-item highlight">`;
                html += `<span class="stat-label">Max Difference:</span>`;
                html += `<span class="stat-value">${maxDiff.toFixed(6)}</span>`;
                html += `</div>`;
                html += `<div class="stat-item highlight">`;
                html += `<span class="stat-label">Cosine Similarity:</span>`;
                html += `<span class="stat-value">${cosineSim.toFixed(6)}</span>`;
                html += `</div>`;
                
                // Comparison info
                html += `<div class="stat-item">`;
                html += `<span class="stat-label">Elements Compared:</span>`;
                html += `<span class="stat-value">${stats.comparison_info.elements_compared}</span>`;
                html += `</div>`;
                html += `<div class="stat-item ${isIdentical ? 'highlight' : ''}">`;
                html += `<span class="stat-label">Values Identical:</span>`;
                html += `<span class="stat-value">${isIdentical ? '✓ YES' : '✗ NO'}</span>`;
                html += `</div>`;
                
                html += '</div>';
                
                // Add interpretation note
                if (isIdentical) {
                    html += '<div style="text-align: center; margin-top: 10px; padding: 8px; background-color: #d4edda; border-radius: 4px; color: #155724;">';
                    html += '🎉 <strong>Values are identical!</strong> This mapping reveals the tensors contain the same data.';
                    html += '</div>';
                } else if (cosineSim > 0.999 && maxDiff < 1e-3) {
                    html += '<div style="text-align: center; margin-top: 10px; padding: 8px; background-color: #d4edda; border-radius: 4px; color: #155724;">';
                    html += '✅ <strong>Values are very similar!</strong> This mapping reveals nearly identical tensor data.';
                    html += '</div>';
                } else if (cosineSim > 0.99 && maxDiff < 0.1) {
                    html += '<div style="text-align: center; margin-top: 10px; padding: 8px; background-color: #d4edda; border-radius: 4px; color: #155724;">';
                    html += '✅ <strong>Good alignment found!</strong> This mapping shows high similarity between tensors.';
                    html += '</div>';
                } else if (cosineSim > 0.5) {
                    html += '<div style="text-align: center; margin-top: 10px; padding: 8px; background-color: #fff3cd; border-radius: 4px; color: #856404;">';
                    html += '⚠️ Moderate similarity. Try adjusting dimension mappings for better alignment.';
                    html += '</div>';
                } else {
                    html += '<div style="text-align: center; margin-top: 10px; padding: 8px; background-color: #f8d7da; border-radius: 4px; color: #721c24;">';
                    html += '❌ Low similarity. Try different dimension mappings to explore other alignments.';
                    html += '</div>';
                }
                
                html += '</div>';
            } else if (result.summary_stats && result.summary_stats.error) {
                html += `<div class="summary-stats error" style="margin-bottom: 15px;">`;
                html += `<strong>Statistics Error:</strong> ${result.summary_stats.error}`;
                html += `</div>`;
            }
            
            html += '<div class="comparison-info">';
            html += `<p><strong>Manual Mapping Applied</strong></p>`;
            html += `<p>Tensor 1 slice: [${result.tensor1_slice_info || 'N/A'}]</p>`;
            html += `<p>Tensor 2 slice: [${result.tensor2_slice_info || 'N/A'}]</p>`;
            html += '</div>';
            
            // Create table showing values side by side
            if (result.tensor1_values || result.tensor2_values) {
                html += '<div class="values-table">';
                html += '<table style="width: 100%; border-collapse: collapse; margin-top: 10px;">';
                html += '<thead><tr><th style="border: 1px solid #ccc; padding: 8px;">Index</th>';
                
                if (result.tensor1_values) {
                    html += '<th style="border: 1px solid #ccc; padding: 8px; background-color: #e3f2fd;">Tensor 1</th>';
                }
                if (result.tensor2_values) {
                    html += '<th style="border: 1px solid #ccc; padding: 8px; background-color: #fff3e0;">Tensor 2</th>';
                }
                if (result.tensor1_values && result.tensor2_values) {
                    html += '<th style="border: 1px solid #ccc; padding: 8px; background-color: #f3e5f5;">Difference</th>';
                }
                
                html += '</tr></thead><tbody>';
                
                const maxLength = Math.max(
                    result.tensor1_values ? result.tensor1_values.length : 0,
                    result.tensor2_values ? result.tensor2_values.length : 0
                );
                
                for (let i = 0; i < maxLength; i++) {
                    html += '<tr>';
                    html += `<td style="border: 1px solid #ccc; padding: 8px; font-weight: bold;">${i}</td>`;
                    
                    const val1 = result.tensor1_values && i < result.tensor1_values.length ? result.tensor1_values[i] : null;
                    const val2 = result.tensor2_values && i < result.tensor2_values.length ? result.tensor2_values[i] : null;
                    
                    if (result.tensor1_values) {
                        const formatted1 = val1 !== null ? (typeof val1 === 'number' ? val1.toFixed(6) : val1) : 'N/A';
                        html += `<td style="border: 1px solid #ccc; padding: 8px; background-color: #e3f2fd;">${formatted1}</td>`;
                    }
                    
                    if (result.tensor2_values) {
                        const formatted2 = val2 !== null ? (typeof val2 === 'number' ? val2.toFixed(6) : val2) : 'N/A';
                        html += `<td style="border: 1px solid #ccc; padding: 8px; background-color: #fff3e0;">${formatted2}</td>`;
                    }
                    
                    if (result.tensor1_values && result.tensor2_values && val1 !== null && val2 !== null) {
                        const diff = val1 - val2;
                        const diffFormatted = Math.abs(diff) < 1e-10 ? '0.000000' : diff.toFixed(6);
                        const diffColor = Math.abs(diff) > 1e-6 ? '#ffebee' : '#e8f5e8';
                        html += `<td style="border: 1px solid #ccc; padding: 8px; background-color: ${diffColor};">${diffFormatted}</td>`;
                    }
                    
                    html += '</tr>';
                }
                
                html += '</tbody></table>';
                html += '</div>';
            }
            
            html += '</div>';
            displayDiv.innerHTML = html;
        }
        
        function toggleAutoUpdate(matchIndex) {
            const checkbox = document.getElementById(`auto-update-${matchIndex}`);
            console.log(`Auto-update for match ${matchIndex}: ${checkbox.checked ? 'enabled' : 'disabled'}`);
        }
        
        function resetManualSliders(matchIndex) {
            const shapes = originalShapes[matchIndex];
            if (!shapes) return;
            
            // Reset all tensor 1 sliders
            if (shapes.tensor1_shape) {
                for (let i = 0; i < shapes.tensor1_shape.length; i++) {
                    const slider = document.getElementById(`t1-dim${i}-slider-${matchIndex}`);
                    const input = document.getElementById(`t1-dim${i}-input-${matchIndex}`);
                    const valueSpan = document.getElementById(`t1-dim${i}-value-${matchIndex}`);
                    
                    if (slider) slider.value = 0;
                    if (input) input.value = 0;
                    if (valueSpan) valueSpan.textContent = '0';
                }
            }
            
            // Reset all tensor 2 sliders
            if (shapes.tensor2_shape) {
                for (let i = 0; i < shapes.tensor2_shape.length; i++) {
                    const slider = document.getElementById(`t2-dim${i}-slider-${matchIndex}`);
                    const input = document.getElementById(`t2-dim${i}-input-${matchIndex}`);
                    const valueSpan = document.getElementById(`t2-dim${i}-value-${matchIndex}`);
                    
                    if (slider) slider.value = 0;
                    if (input) input.value = 0;
                    if (valueSpan) valueSpan.textContent = '0';
                }
            }
            
            // Auto-apply if enabled
            const autoUpdateCheckbox = document.getElementById(`auto-update-${matchIndex}`);
            if (autoUpdateCheckbox && autoUpdateCheckbox.checked) {
                applyDimensionMapping(matchIndex);
            }
        }
        
        function copyTensor1ToTensor2(matchIndex) {
            const shapes = originalShapes[matchIndex];
            if (!shapes || !shapes.tensor1_shape || !shapes.tensor2_shape) return;
            
            // Copy values from tensor 1 sliders to tensor 2 sliders (up to the minimum length)
            const minDims = Math.min(shapes.tensor1_shape.length, shapes.tensor2_shape.length);
            
            for (let i = 0; i < minDims; i++) {
                const t1Slider = document.getElementById(`t1-dim${i}-slider-${matchIndex}`);
                const t2Slider = document.getElementById(`t2-dim${i}-slider-${matchIndex}`);
                const t2Input = document.getElementById(`t2-dim${i}-input-${matchIndex}`);
                const t2ValueSpan = document.getElementById(`t2-dim${i}-value-${matchIndex}`);
                
                if (t1Slider && t2Slider) {
                    // Clamp to target tensor's dimension size
                    const t1Value = parseInt(t1Slider.value);
                    const maxValue = parseInt(t2Slider.max);
                    const clampedValue = Math.min(t1Value, maxValue);
                    
                    t2Slider.value = clampedValue;
                    if (t2Input) t2Input.value = clampedValue;
                    if (t2ValueSpan) t2ValueSpan.textContent = clampedValue;
                }
            }
            
            // Auto-apply if enabled
            const autoUpdateCheckbox = document.getElementById(`auto-update-${matchIndex}`);
            if (autoUpdateCheckbox && autoUpdateCheckbox.checked) {
                applyDimensionMapping(matchIndex);
            }
        }
        
        function tryCommonMappings(matchIndex) {
            const shapes = originalShapes[matchIndex];
            if (!shapes || !shapes.tensor1_shape || !shapes.tensor2_shape) return;
            
            const t1Shape = shapes.tensor1_shape;
            const t2Shape = shapes.tensor2_shape;
            
            // Define some common mapping patterns to try
            const mappings = [
                {
                    name: "Identity mapping (0,0,0...)",
                    t1: new Array(t1Shape.length).fill(0),
                    t2: new Array(t2Shape.length).fill(0)
                }
            ];
            
            // Add pattern for removing leading 1 dimensions
            if (t2Shape[0] === 1 && t2Shape.length > t1Shape.length) {
                mappings.push({
                    name: "Skip leading 1 dim in T2",
                    t1: new Array(t1Shape.length).fill(0),
                    t2: [0, ...new Array(t1Shape.length).fill(0)]
                });
            }
            
            if (t1Shape[0] === 1 && t1Shape.length > t2Shape.length) {
                mappings.push({
                    name: "Skip leading 1 dim in T1", 
                    t1: [0, ...new Array(t2Shape.length).fill(0)],
                    t2: new Array(t2Shape.length).fill(0)
                });
            }
            
            // Show dialog with mapping options
            let message = "Choose a common mapping pattern:\\n\\n";
            message += `Tensor 1 shape: [${t1Shape.join(', ')}]\\n`;
            message += `Tensor 2 shape: [${t2Shape.join(', ')}]\\n\\n`;
            
            mappings.forEach((mapping, idx) => {
                message += `${idx + 1}. ${mapping.name}\\n`;
            });
            
            const choice = prompt(message + "\\nEnter number (1-" + mappings.length + "), or cancel:");
            const choiceNum = parseInt(choice);
            
            if (choiceNum >= 1 && choiceNum <= mappings.length) {
                const mapping = mappings[choiceNum - 1];
                
                // Apply the mapping
                applyMappingPattern(matchIndex, mapping.t1, mapping.t2);
                
                // Auto-apply if enabled
                const autoUpdateCheckbox = document.getElementById(`auto-update-${matchIndex}`);
                if (autoUpdateCheckbox && autoUpdateCheckbox.checked) {
                    applyDimensionMapping(matchIndex);
                }
            }
        }
        
        function applyMappingPattern(matchIndex, t1Values, t2Values) {
            // Set tensor 1 sliders
            t1Values.forEach((value, i) => {
                const slider = document.getElementById(`t1-dim${i}-slider-${matchIndex}`);
                const input = document.getElementById(`t1-dim${i}-input-${matchIndex}`);
                const valueSpan = document.getElementById(`t1-dim${i}-value-${matchIndex}`);
                
                if (slider) {
                    const clampedValue = Math.max(0, Math.min(value, parseInt(slider.max)));
                    slider.value = clampedValue;
                    if (input) input.value = clampedValue;
                    if (valueSpan) valueSpan.textContent = clampedValue;
                }
            });
            
            // Set tensor 2 sliders
            t2Values.forEach((value, i) => {
                const slider = document.getElementById(`t2-dim${i}-slider-${matchIndex}`);
                const input = document.getElementById(`t2-dim${i}-input-${matchIndex}`);
                const valueSpan = document.getElementById(`t2-dim${i}-value-${matchIndex}`);
                
                if (slider) {
                    const clampedValue = Math.max(0, Math.min(value, parseInt(slider.max)));
                    slider.value = clampedValue;
                    if (input) input.value = clampedValue;
                    if (valueSpan) valueSpan.textContent = clampedValue;
                }
            });
        }
        
        function updateManualCountSlider(matchIndex) {
            const slider = document.getElementById(`manual-count-slider-${matchIndex}`);
            const valueSpan = document.getElementById(`manual-count-value-${matchIndex}`);
            const input = document.getElementById(`manual-count-input-${matchIndex}`);
            
            if (slider && valueSpan && input) {
                const value = slider.value;
                valueSpan.textContent = value;
                input.value = value;
                
                // Auto-apply if enabled
                const autoUpdateCheckbox = document.getElementById(`auto-update-${matchIndex}`);
                if (autoUpdateCheckbox && autoUpdateCheckbox.checked) {
                    // Debounce the auto-update to avoid too many requests
                    clearTimeout(window[`autoUpdateCountTimer_${matchIndex}`]);
                    window[`autoUpdateCountTimer_${matchIndex}`] = setTimeout(() => {
                        applyDimensionMapping(matchIndex);
                    }, 500); // 500ms delay
                }
            }
        }
        
        function syncManualCountFromInput(matchIndex) {
            const slider = document.getElementById(`manual-count-slider-${matchIndex}`);
            const valueSpan = document.getElementById(`manual-count-value-${matchIndex}`);
            const input = document.getElementById(`manual-count-input-${matchIndex}`);
            
            if (slider && valueSpan && input) {
                let value = parseInt(input.value) || 10;
                const max = parseInt(slider.max);
                const min = parseInt(slider.min);
                
                // Clamp value to slider range
                value = Math.max(min, Math.min(max, value));
                
                slider.value = value;
                valueSpan.textContent = value;
                input.value = value; // Update input in case it was clamped
                
                // Auto-apply if enabled
                const autoUpdateCheckbox = document.getElementById(`auto-update-${matchIndex}`);
                if (autoUpdateCheckbox && autoUpdateCheckbox.checked) {
                    applyDimensionMapping(matchIndex);
                }
            }
        }
        
        async function quickManualMapping(matchIndex) {
            // Open tensor values if not already open
            const valuesContainer = document.getElementById(`values-${matchIndex}`);
            if (valuesContainer.style.display === 'none') {
                await showTensorValues(matchIndex);
            }
            
            // Switch directly to manual mapping mode
            const mappingDiv = document.getElementById(`dimension-mapping-${matchIndex}`);
            const autoDiv = document.getElementById(`auto-controls-${matchIndex}`);
            
            if (mappingDiv && autoDiv) {
                // Switch to manual mapping mode
                mappingDiv.style.display = 'block';
                autoDiv.style.display = 'none';
                mappingMode[matchIndex] = true;
                
                // Initialize dimension mapping if not already done
                if (!originalShapes[matchIndex]) {
                    await initializeDimensionMapping(matchIndex);
                }
                
                // Scroll to the manual mapping interface
                mappingDiv.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
                
                // Highlight the interface briefly
                mappingDiv.style.border = '2px solid #17a2b8';
                setTimeout(() => {
                    mappingDiv.style.border = '';
                }, 2000);
            }
        }
        
        // Initialize
        setupDropZone('model1-drop', 'model1-file', 'model1-info');
        setupDropZone('model2-drop', 'model2-file', 'model2-info');
        
        document.getElementById('upload-btn').addEventListener('click', uploadAndCompare);
    </script>
</body>
</html>